/*
// $Id$
// Enki generates and implements the JMI and MDR APIs for MOF metamodels.
// Copyright (C) 2007-2007 The Eigenbase Project
// Copyright (C) 2007-2007 Disruptive Tech
// Copyright (C) 2007-2007 LucidEra, Inc.
//
// This library is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or (at
// your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/
package org.eigenbase.enki.hibernate.codegen;

import java.io.*;
import java.security.*;
import java.util.*;
import java.util.logging.*;

import javax.jmi.model.*;
import javax.jmi.reflect.*;

import org.eigenbase.enki.codegen.*;
import org.eigenbase.enki.codegen.Generator.*;
import org.eigenbase.enki.hibernate.jmi.*;
import org.eigenbase.enki.hibernate.storage.*;
import org.eigenbase.enki.jmi.impl.*;
import org.eigenbase.enki.util.*;

/**
 * HibernateJavaHandler generates Java implementations for the JMI/MOF
 * interfaces generated by the {@link JmiTemplateHandler default code 
 * generation}.
 *  
 * @author Stephan Zuercher
 */
public class HibernateJavaHandler
    extends JavaHandlerBase
    implements 
        AssociationHandler, 
        ClassInstanceHandler, 
        ClassProxyHandler,
        PackageHandler
{
    // REVIEW: SWZ: 11/7/2007: Relies on JmiTemplateHandler to throw
    // for cases (e.g., Import, StructureType) that we don't handle yet.    

    /** 
     * Suffix for implementation class names and association implementation
     * methods.
     */
    public static final String IMPL_SUFFIX = "$Impl";

    /**
     * Name of the base class for classes that implement {@link RefObject}.
     */
    public static final JavaClassReference REF_OBJECT_IMPL_CLASS = 
        new JavaClassReference(HibernateRefObject.class);

    /**
     * Name of the base class for classes that implement {@link RefClass}.
     */
    public static final JavaClassReference REF_CLASS_IMPL_CLASS = 
        new JavaClassReference(HibernateRefClass.class);
    
    /**
     * Name of the base class for classes that implement {@link RefPackage}.
     */
    public static final JavaClassReference REF_PACKAGE_IMPL_CLASS = 
        new JavaClassReference(HibernateRefPackage.class);

    /**
     * Name of the base class for classes that implement {@link RefAssociation}
     * for one-to-many associations.
     */
    public static final JavaClassReference REF_ASSOCIATION_ONE_TO_MANY_IMPL_CLASS = 
        new JavaClassReference(HibernateOneToManyRefAssociation.class);

    /**
     * Name of the base class for classes that implement {@link RefAssociation}
     * for one-to-one associations.
     */
    public static final JavaClassReference REF_ASSOCIATION_ONE_TO_ONE_IMPL_CLASS =
        new JavaClassReference(HibernateOneToOneRefAssociation.class);
    
    /**
     * Name of the base class for classes that implement {@link RefAssociation}
     * for many-to-many associations.
     */
    public static final JavaClassReference REF_ASSOCIATION_MANY_TO_MANY_IMPL_CLASS =
        new JavaClassReference(HibernateManyToManyRefAssociation.class);
    
    /**
     * Name of the base class for stored objects.
     */
    public static final JavaClassReference OBJECT_IMPL_CLASS = 
        new JavaClassReference(HibernateObject.class, true);
    
    /**
     * Name of the base class for stored objects that are participants in one 
     * or more types of Association.
     */
    public static final JavaClassReference ASSOCIABLE_INTERFACE = 
        new JavaClassReference(HibernateAssociable.class, true);

    /**
     * Name of the base class for all associations.
     */
    public static final JavaClassReference ASSOCIATION_BASE_CLASS = 
        new JavaClassReference(HibernateAssociation.class, true);
    
    /**
     * Name of the class for one-to-one associations.
     */
    public static final JavaClassReference ASSOCIATION_ONE_TO_ONE_IMPL_CLASS = 
        new JavaClassReference(HibernateOneToOneAssociation.class, true);
    
    /**
     * Name of the class for one-to-many associations.
     */
    public static final JavaClassReference ASSOCIATION_ONE_TO_MANY_IMPL_CLASS = 
        new JavaClassReference(HibernateOneToManyAssociation.class, true);
    
    /**
     * Name of the class for many-to-many associations.
     */
    public static final JavaClassReference ASSOCIATION_MANY_TO_MANY_IMPL_CLASS = 
        new JavaClassReference(HibernateManyToManyAssociation.class, true);

    public static final JavaClassReference MULTIPLICITY_ENUM =
        new JavaClassReference(Multiplicity.class, true);
    
    private static final JavaClassReference LIST_PROXY_CLASS = 
        new JavaClassReference(ListProxy.class, true);
    
    /** Class comment for {@link RefPackage} implementations. */
    private static final String PACKAGE_IMPL_COMMENT = 
        "{0} package implementation.";

    /** Class comment for {@link RefClass} implementations. */
    private static final String CLASS_PROXY_IMPL_COMMENT = 
        "{0} class proxy implementation.";

    /** Class comment for {@link RefAssociation} implementations. */
    private static final String ASSOC_IMPL_COMMENT = 
        "{0} association implementation.";

    /**
     * Name of the class used to stored unordered collections of attributes.
     */
    private static final JavaClassReference COLLECTION_IMPL_CLASS = 
        new JavaClassReference(HashSet.class);

    /**
     * Name of the class used to stored ordered collections of attributes.
     */
    private static final JavaClassReference ORDERED_COLLECTION_IMPL_CLASS = 
        new JavaClassReference(ArrayList.class);

    private static final JavaClassReference JAVA_UTIL_LIST_CLASS =
        new JavaClassReference(List.class, true);
    
    private static final JavaClassReference JAVA_UTIL_COLLECTIONS_CLASS =
        new JavaClassReference(Collections.class, true);
    
    private static final JavaClassReference GENERIC_COLLECTIONS_CLASS =
        new JavaClassReference(GenericCollections.class, true);
    
    private static final JavaClassReference UNSUPPORTED_OPERATION_EXCEPTION =
        new JavaClassReference(UnsupportedOperationException.class, true);
    
    private static final JavaClassReference METAMODEL_INITIALIZER_CLASS =
        new JavaClassReference(MetamodelInitializer.class, true);
    
    private static final JavaClassReference[] CLASS_INSTANCE_REFS = {
        OBJECT_IMPL_CLASS,
        ASSOCIABLE_INTERFACE,
        ASSOCIATION_BASE_CLASS,
        ASSOCIATION_ONE_TO_ONE_IMPL_CLASS,        
        ASSOCIATION_ONE_TO_MANY_IMPL_CLASS,
        ASSOCIATION_MANY_TO_MANY_IMPL_CLASS,
        LIST_PROXY_CLASS,
        JAVA_UTIL_LIST_CLASS,
        JAVA_UTIL_COLLECTIONS_CLASS,
        GENERIC_COLLECTIONS_CLASS,
        UNSUPPORTED_OPERATION_EXCEPTION,
    };
    
    private static final int numPasses = 2;
    private int numTransientPasses;
    
    private final Logger log = 
        Logger.getLogger(HibernateJavaHandler.class.getName());

    private final TransientImplementationHandler transientHandler;
    
    private Map<MofClass, String> classIdentifierMap;
    
    private Map<Association, AssociationInfo> assocInfoMap;
    
    private Map<Classifier, List<MofClassAttribPair>> componentAttribMap;
    
    public HibernateJavaHandler()
    {
        super();
        
        this.transientHandler = new TransientImplementationHandler() {
            @Override
            protected String convertToTypeName(String entityName)
                throws GenerationException
            {
                return entityName + IMPL_SUFFIX;
            }
            
            @Override
            protected String computeSuffix(String baseSuffix)
            {
                if (baseSuffix != null) {
                    return baseSuffix + IMPL_SUFFIX;
                }
                return IMPL_SUFFIX;
            }
            
            @Override
            protected void generateCustomPackageInit(MofPackage pkg)
            {
                writeln(
                    METAMODEL_INITIALIZER_CLASS,
                    ".getCurrentInitializer().setRefMetaObject(this, ", 
                    QUOTE, pkg.getName(), QUOTE, ");");
            }
            
            @Override
            protected void generateCustomAssociationInit(Association assoc)
            {
                writeln(
                    METAMODEL_INITIALIZER_CLASS,
                    ".getCurrentInitializer().setRefMetaObject(this, ", 
                    QUOTE, assoc.getName(), QUOTE, ");");
            }

            @Override
            protected void generateCustomClassProxyInit(MofClass cls)
            {
                writeln(
                    METAMODEL_INITIALIZER_CLASS,
                    ".getCurrentInitializer().setRefMetaObject(this, ", 
                    QUOTE, cls.getName(), QUOTE, ");");
            }
        };
        
        this.classIdentifierMap = new HashMap<MofClass, String>();
        this.assocInfoMap = new LinkedHashMap<Association, AssociationInfo>();
        this.componentAttribMap = 
            new HashMap<Classifier, List<MofClassAttribPair>>();
    }
    
    @Override
    public void setGenerator(Generator generator)
    {
        super.setGenerator(generator);
        
        transientHandler.setGenerator(generator);
    }

    @Override
    public void setOutputDir(File outputDir)
    {
        super.setOutputDir(outputDir);
        
        transientHandler.setOutputDir(outputDir);
    }

    @Override
    public int getNumPasses()
    {
        numTransientPasses = transientHandler.getNumPasses();
        
        return Math.max(numPasses, numTransientPasses);
    }
    
    @Override
    public void beginGeneration()
        throws GenerationException
    {
        super.beginGeneration();
        
        transientHandler.beginGeneration();
    }

    @Override
    public void endGeneration(boolean throwing)
        throws GenerationException
    {
        super.endGeneration(throwing);
        
        transientHandler.endGeneration(throwing);
    }

    public void generateAssociation(Association assoc)
        throws GenerationException
    {
        if (HibernateCodeGenUtils.isTransient(assoc)) {
            if (getPassIndex() < numTransientPasses) {
                log.fine("Delegating Transient Association Implementation");
                transientHandler.generateAssociation(assoc);
            }
            return;
        }

        if (getPassIndex() > 0) {
            return;
        }
        
        String interfaceName = generator.getTypeName(assoc);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        log.fine("Generating Association Implementation '" + typeName + "'");

        AssociationInfo assocInfo = new AssociationInfo(generator, assoc);
        assocInfoMap.put(assoc, assocInfo);
        
        open(typeName);
        try {
            String superClass = makeType(assocInfo);
            
            writeClassHeader(
                assoc,
                typeName, 
                superClass,
                new String[] { interfaceName }, 
                JavaClassReference.computeImports(MULTIPLICITY_ENUM),
                false,
                ASSOC_IMPL_COMMENT);
        
            startConstructorBlock(
                assoc, 
                new String[] { REF_PACKAGE_CLASS.toString() }, 
                new String[] { "container" },
                true,
                IMPL_SUFFIX);
            switch(assocInfo.getKind()) {
            case ONE_TO_ONE:
                writeln(
                    "super(container, ", 
                    QUOTE, assocInfo.getBaseName(), QUOTE, ", ",
                    QUOTE, assocInfo.getEndName(0, true), QUOTE, ", ",
                    assocInfo.getEndType(0), ".class, ",
                    QUOTE, assocInfo.getEndName(1, true), QUOTE, ", ",
                    assocInfo.getEndType(1), ".class);");
                break;
                
            case ONE_TO_MANY:
            case MANY_TO_MANY:
                writeln(
                    "super(container, ", 
                    QUOTE, assocInfo.getBaseName(), QUOTE, ", ",
                    QUOTE, assocInfo.getEndName(0, true), QUOTE, ", ",
                    assocInfo.getEndType(0), ".class, ",
                    MULTIPLICITY_ENUM, ".", 
                    Multiplicity.fromMultiplicityType(
                        assocInfo.getEnd(0).getMultiplicity()), ", ",
                    QUOTE, assocInfo.getEndName(1, true), QUOTE, ", ",
                    assocInfo.getEndType(1), ".class, ",
                    MULTIPLICITY_ENUM, ".", 
                    Multiplicity.fromMultiplicityType(
                        assocInfo.getEnd(1).getMultiplicity()),
                    ");");
                break;
            }
            newLine();
            writeln(
                METAMODEL_INITIALIZER_CLASS,
                ".getCurrentInitializer().setRefMetaObject(this, ", 
                QUOTE, assoc.getName(), QUOTE, ");");

            endBlock();
            newLine();
            
            // exists
            startGenericMethodBlock(
                assoc,
                "boolean",
                "exists", 
                assocInfo.getEndTypes(),
                assocInfo.getEndNames());
            writeln(
                "return super.exists(", 
                assocInfo.getEndName(0), ", ",
                assocInfo.getEndName(1), ");");
            endBlock();
            newLine();
            
            // get end1 from end2
            if (assocInfo.getEnd(0).isNavigable()) {
                boolean ordered = assocInfo.isOrdered(0);
                String returnTypeName = 
                    assocInfo.isSingle(0)
                        ? assocInfo.getEndType(0)
                        : generator.getCollectionType(
                            ordered 
                                ? JmiTemplateHandler.ORDERED_COLLECTION_CLASS
                                : JmiTemplateHandler.COLLECTION_CLASS,
                            assocInfo.getEndType(0));
                startGenericMethodBlock(
                    assoc,
                    returnTypeName,
                    generator.getAccessorName(assocInfo.getEnd(0), null),
                    new String[] { assocInfo.getEndType(1) },
                    new String[] { assocInfo.getEndName(1) });
                switch(assocInfo.getKind()) {
                case ONE_TO_ONE:
                    writeln("return getParentOf(", assocInfo.getEndName(1), ");");
                    break;

                case ONE_TO_MANY:
                    if (assocInfo.isSingle(0)) {
                        writeln(
                            "return getParentOf(", 
                            assocInfo.getEndName(1), ", ",
                            assocInfo.getEndType(0), ".class);");
                    } else if (assocInfo.isOrdered(0)) {
                        writeln(
                            "return (",
                            returnTypeName,
                            ")getChildrenOf(",
                            assocInfo.getEndName(1), ", ",
                            assocInfo.getEndType(0), ".class);");
                    } else {
                        writeln(
                            "return getChildrenOf(",
                            assocInfo.getEndName(1), ", ",
                            assocInfo.getEndType(0), ".class);");
                    }
                    break;
                    
                case MANY_TO_MANY:
                    if (assocInfo.isOrdered(0)) {
                        writeln(
                            "return (",
                            returnTypeName,
                            ")getSourceOf(", assocInfo.getEndName(1), ");");                        
                    } else {
                        writeln("return getSourceOf(", assocInfo.getEndName(1), ");");
                    }
                }
                endBlock();
                newLine();
            }
            
            // get end2 from end1
            if (assocInfo.getEnd(1).isNavigable()) {
                boolean ordered = assocInfo.isOrdered(1);
                String returnTypeName = 
                    assocInfo.isSingle(1) 
                        ? assocInfo.getEndType(1)
                        : generator.getCollectionType(
                            ordered 
                                ? JmiTemplateHandler.ORDERED_COLLECTION_CLASS
                                : JmiTemplateHandler.COLLECTION_CLASS,
                            assocInfo.getEndType(1));
                startGenericMethodBlock(
                    assoc,
                    returnTypeName,
                    generator.getAccessorName(assocInfo.getEnd(1), null),
                    new String[] { assocInfo.getEndType(0) },
                    new String[] { assocInfo.getEndName(0) });
                switch(assocInfo.getKind()) {
                case ONE_TO_ONE:
                    writeln("return getChildOf(", assocInfo.getEndName(0), ");");
                    break;

                case ONE_TO_MANY:
                    if (assocInfo.isSingle(1)) {
                        writeln(
                            "return getParentOf(", 
                            assocInfo.getEndName(0), ", ",
                            assocInfo.getEndType(1), ".class);");
                    } else if (assocInfo.isOrdered(1)) {
                        writeln(
                            "return (",
                            returnTypeName,
                            ")getChildrenOf(", 
                            assocInfo.getEndName(0), ", ",
                            assocInfo.getEndType(1), ".class);");
                    } else {
                        writeln(
                            "return getChildrenOf(", 
                            assocInfo.getEndName(0), ", ",
                            assocInfo.getEndType(1), ".class);");
                    }
                    break;
                    
                case MANY_TO_MANY:
                    if (assocInfo.isOrdered(1)) {
                        writeln(
                            "return (",
                            returnTypeName,
                            ")getTargetOf(", assocInfo.getEndName(0), ");");
                    } else {
                        writeln(
                            "return getTargetOf(", assocInfo.getEndName(0), ");");
                    }
                }
                endBlock();
                newLine();
            }

            if (assocInfo.isChangeable(0) && assocInfo.isChangeable(1)) {
                // add
                startGenericMethodBlock(
                    assoc,
                    "boolean",
                    "add",
                    assocInfo.getEndTypes(),
                    assocInfo.getEndNames());
                writeln(
                    "return super.add(",
                    assocInfo.getEndName(0),
                    ", ",
                    assocInfo.getEndName(1),
                    ");");
                endBlock();

                newLine();
                
                // remove
                startGenericMethodBlock(
                    assoc,
                    "boolean",
                    "remove",
                    assocInfo.getEndTypes(),
                    assocInfo.getEndNames());
                writeln(
                    "return super.remove(",
                    assocInfo.getEndName(0),
                    ", ",
                    assocInfo.getEndName(1),
                    ");");
                endBlock();
            }
            
            writeEntityFooter();
        }
        finally {
            close();
        }            
    }

    public void generateClassInstance(MofClass cls)
        throws GenerationException
    {
        if (HibernateCodeGenUtils.isTransient(cls)) {
            if (getPassIndex() < numTransientPasses) {
                log.fine("Delegating Transient Class Instance Implementation");
                transientHandler.generateClassInstance(cls);
            }
            return;
        }

        // Build attribute information
        Collection<Attribute> instanceAttributes =
            contentsOfType(
                cls,
                HierachySearchKindEnum.INCLUDE_SUPERTYPES, 
                VisibilityKindEnum.PUBLIC_VIS,
                ScopeKindEnum.INSTANCE_LEVEL,
                Attribute.class);
        ArrayList<Attribute> nonDerivedAttribs = 
            new ArrayList<Attribute>();
        Set<Attribute> nonDataTypeAttribs = new HashSet<Attribute>();
        for(Attribute attrib: instanceAttributes) {
            if (attrib.isDerived()) {
                continue;
            }
            
            nonDerivedAttribs.add(attrib);

            boolean isDataType = attrib.getType() instanceof DataType;
            
            if (!isDataType) {
                nonDataTypeAttribs.add(attrib);
            }
        }

        if (getPassIndex() == 0 && !cls.isAbstract()) {
            for(Attribute attrib: nonDataTypeAttribs) {
                addComponentAttrib(attrib.getType(), cls, attrib);
            }
        }
        
        if (checkPassIndex(1)) {
            return;
        }
        
        String interfaceName = generator.getTypeName(cls);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        if (cls.isAbstract()) {
            log.fine(
                "Skipping Class Instance Implementation '" + typeName + "'");
            return;
        }
        
        log.fine(
            "Generating Class Instance Implementation '" + typeName + "'");

        Collection<Reference> instanceReferences =
            contentsOfType(
                cls,
                HierachySearchKindEnum.INCLUDE_SUPERTYPES, 
                VisibilityKindEnum.PUBLIC_VIS,
                Reference.class);

        Map<Reference, ReferenceInfo> refInfoMap =
            new HashMap<Reference, ReferenceInfo>();
        for(Reference ref: instanceReferences) {
            ReferenceInfo refInfo = new ReferenceInfo(generator, ref);
            refInfoMap.put(ref, refInfo);
        }
        
        Map<Association, ReferenceInfo> unrefAssocRefInfoMap =
            new HashMap<Association, ReferenceInfo>();
        
        Collection<Association> unreferencedAssociations = 
            HibernateCodeGenUtils.findUnreferencedAssociations(
                generator,
                assocInfoMap,
                cls,
                instanceReferences, 
                unrefAssocRefInfoMap);
        
        boolean hasAssociations = 
            !instanceReferences.isEmpty() || 
            !unreferencedAssociations.isEmpty();
        
        open(typeName);
        try {            
            String[] interfaces;
            if (hasAssociations) {
                interfaces = new String[] { 
                    interfaceName, ASSOCIABLE_INTERFACE.toString()
                };
            } else {
                interfaces = new String[] { interfaceName };
            }
            
            writeClassHeader(
                cls, 
                typeName,
                REF_OBJECT_IMPL_CLASS.toString(),
                interfaces,
                JavaClassReference.computeImports(CLASS_INSTANCE_REFS),
                false,
                CLASS_COMMENT);
            
            String classIdentifier = getClassIdentifier(cls);
            writeConstant(
                "String", "_id", "\"" + classIdentifier + "\"", true);
            newLine();
            
            // fields
            writeln("// Attribute Fields");
            Map<Attribute, String> nonDerivedAttribNames = 
                new HashMap<Attribute, String>();
            for(Attribute attrib: nonDerivedAttribs) {
                boolean isDataType = !nonDataTypeAttribs.contains(attrib);
                
                String fieldName;
                if (isDataType) {
                    fieldName = writePrivateField(attrib, false, false);
                } else {
                    fieldName = 
                        writePrivateField(attrib, IMPL_SUFFIX, false, false);
                }
                nonDerivedAttribNames.put(attrib, fieldName);
            }
            newLine();
            
            if (!instanceReferences.isEmpty()) {
                // reference fields
                writeln("// Reference Fields");
                for(Reference ref: instanceReferences) {
                    ReferenceInfo refInfo = refInfoMap.get(ref);
                    writePrivateField(
                        makeType(refInfo.getKind()),
                        refInfo.getFieldName(), 
                        false, 
                        false);
                }
                newLine();
            }
            
            if (!unreferencedAssociations.isEmpty()) {
                // TODO: doesn't handle self-referential un-referenced 
                // associations (assuming such a thing is even valid)
                
                // unreferenced association fields
                writeln("// Unreferenced Association Fields");
                for(Association unref: unreferencedAssociations) {
                    ReferenceInfo refInfo = unrefAssocRefInfoMap.get(unref);
                    
                    writePrivateField(
                        makeType(refInfo.getKind()),
                        refInfo.getFieldName(),
                        false,
                        false);
                }
                newLine();
            }
            
            // Constructors
            generateClassInstanceConstructors(
                cls,
                instanceAttributes,
                nonDerivedAttribs,
                nonDerivedAttribNames,
                nonDataTypeAttribs);
            
            // attribute methods
            generateClassInstanceAttribMethods(
                instanceAttributes,
                nonDerivedAttribNames,
                nonDataTypeAttribs);
            
            // reference methods
            generateClassInstanceRefMethods(instanceReferences, refInfoMap);

            // unreferenced association methods
            for(Association unrefAssoc: unreferencedAssociations) {
                ReferenceInfo refInfo = unrefAssocRefInfoMap.get(unrefAssoc);
                
                generateClassInstanceAssocMethods(refInfo);
            }
            
            // TODO: Emit private static final fields for the assoc base names?
            
            // Implement HibernateAssociable
            if (hasAssociations) {
                newLine();
                generateGetAssociationMethod(
                    instanceReferences, refInfoMap,
                    unreferencedAssociations, unrefAssocRefInfoMap);

                newLine();
                generateSetAssociationMethod(
                    instanceReferences, refInfoMap,
                    unreferencedAssociations, unrefAssocRefInfoMap);

                newLine();
                generateGetOrCreateAssociationMethod(
                    instanceReferences, refInfoMap,
                    unreferencedAssociations, unrefAssocRefInfoMap);

                newLine();
                writeln("// Implement HibernateRefObject");
                startBlock("protected void removeAssociations()");
                
                List<ReferenceInfo> refInfos = 
                    gatherRefInfos(
                        instanceReferences, refInfoMap, 
                        unreferencedAssociations, unrefAssocRefInfoMap);
                for(ReferenceInfo refInfo: refInfos) {
                    startConditionalBlock(
                        CondType.IF, 
                        getReferenceAccessorName(refInfo), "() != null");
                    writeln(
                        getReferenceAccessorName(refInfo), 
                        "().removeAll(this);");
                    endBlock();
                }
                endBlock();
            } else {
                newLine();
                writeln("// Implement HibernateRefObject");
                startBlock("protected void removeAssociations()");
                endBlock();
            }

            // TODO: generate constraint checks for association multiplicity
            // bounds.  E.g., either end of a 1-to-1 may be optional, but
            // currently they all are because Hibernate won't let us specify
            // them as not null (inserts with null, then updates).  Check
            // for not-null here.  Similarly for 1-to-many and many-to-many.            
            newLine();
            startBlock(
                "public boolean checkConstraints(",
                JAVA_UTIL_LIST_CLASS, 
                "<String> messages)");
            writeln("// TODO: implement constraint checking");
            writeln("return true;");
            endBlock();
            
            generateRefImmediateComposite(
                cls, refInfoMap, unrefAssocRefInfoMap);
            
            newLine();
            startBlock("protected String getClassIdentifier()");
            writeln("return _id;");
            endBlock();
            
            writeEntityFooter();
        }
        finally {
            close();
        }
    }

    private void addComponentAttrib(
        Classifier type,
        MofClass cls,
        Attribute attrib)
    {
        List<MofClassAttribPair> componentOfList =
            componentAttribMap.get(type);
        
        if (componentOfList == null) {
            componentOfList = new ArrayList<MofClassAttribPair>();
            componentAttribMap.put(type, componentOfList);
        }
        
        componentOfList.add(new MofClassAttribPair(cls, attrib));
    }

    private void generateRefImmediateComposite(
        MofClass cls,
        Map<Reference, ReferenceInfo> refInfoMap,
        Map<Association, ReferenceInfo> unrefAssocInfoMap)
    throws GenerationException
    {
        newLine();
        startBlock(
            "public ", REF_OBJECT_CLASS, " refImmediateComposite()");
        
        // Find the composite associations, if any.  Note that MOF states
        // an object is only allowed to be the component end of a single
        // composite aggregation at a time, so we just traverse all of 
        // the composite aggregates and assume that only one will be valid.
        // This is not presently enforced, however.
        for(ReferenceInfo refInfo: refInfoMap.values()) {                        
            if (refInfo.isComposite()) {
                startConditionalBlock(
                    CondType.IF,
                    getReferenceAccessorName(refInfo), "() != null");
                write(
                    "return ", 
                    generator.getAccessorName(refInfo.getReference()), "()");
                if (!refInfo.isSingle()) {
                    if (refInfo.isOrdered()) {
                        write(".get(0)");
                    } else {
                        write(".iterator().next()");
                    }
                }
                writeln(";");
                endBlock();
            }
        }
        
        for(ReferenceInfo refInfo: unrefAssocInfoMap.values()) {            
            if (refInfo.isComposite()) {
                startConditionalBlock(
                    CondType.IF,
                    getReferenceAccessorName(refInfo), "() != null");
                write(
                    "return ", 
                    getReferenceAccessorName(refInfo), "()");
                
                switch(refInfo.getKind()) {
                case ONE_TO_ONE:
                    if (refInfo.isReferencedEndFirst()) {
                        write(".getParent()");
                    } else {
                        write(".getChild()");
                    }
                    break;
                    
                case ONE_TO_MANY:
                    if (refInfo.isSingle()) {
                        write(".getParent()");
                    } else if (refInfo.isOrdered()) {
                        write(".getChildren().get(0)");
                    } else {
                        write(".getChildren().iterator.next()");
                    }
                    break;
                    
                case MANY_TO_MANY:
                    if (refInfo.isOrdered()) {
                        write(".getTarget().get(0)");
                    } else {
                        write(".getTarget().iterator().next()");
                    }
                    break;
                    
                default:
                    throw new GenerationException("unknown assoc kind");
                }
                
                writeln(";");
                endBlock();
            }
        }

        List<MofClassAttribPair> componentOfList = componentAttribMap.get(cls);
        if (componentOfList != null) {
            writeln(REF_OBJECT_CLASS, " owner;");
            for(MofClassAttribPair clsAttribPair: componentOfList) {
                MofClass ownerCls = clsAttribPair.cls;
                Attribute ownerAttrib = clsAttribPair.attrib;
                
                writeln(
                    "owner = findCompositeOwner(",
                    generator.getTypeName(ownerCls, IMPL_SUFFIX), ".class, ",
                    QUOTE, 
                    generator.getSimpleTypeName(ownerAttrib, IMPL_SUFFIX),
                    QUOTE, ");");
                startConditionalBlock(CondType.IF, "owner != null");
                writeln("return owner;");
                endBlock();
            }
        }
        
        // no composite associations (or none in use)
        writeln("return null;");
        
        endBlock();
    }

    private void generateGetAssociationMethod(
        Collection<Reference> instanceReferences,
        Map<Reference, ReferenceInfo> refInfoMap,
        Collection<Association> unreferencedAssociations,
        Map<Association, ReferenceInfo> unrefAssocRefInfoMap)
    throws GenerationException
    {
        writeln("// Implement HibernateAssociable");
        startBlock(
            "public ",
            ASSOCIATION_BASE_CLASS,
            " getAssociation(String type, boolean firstEnd)");

        List<ReferenceInfo> refInfos = 
            gatherRefInfos(
                instanceReferences,
                refInfoMap,
                unreferencedAssociations,
                unrefAssocRefInfoMap);

        generateGenericAssociationMethod(
            refInfos,
            new AssocMethodGenerator() {
                public void generate(ReferenceInfo refInfo)
                    throws GenerationException
                {
                    writeln(
                        "return ", getReferenceAccessorName(refInfo), "();");
                }
                
            });
        
        endBlock();
    }

    private void generateGenericAssociationMethod(
        List<ReferenceInfo> refInfos,
        AssocMethodGenerator assocMethodGenerator) 
    throws GenerationException
    {
        List<ReferenceInfo> firstEndsExposed = new ArrayList<ReferenceInfo>();
        List<ReferenceInfo> secondEndsExposed = new ArrayList<ReferenceInfo>();
        for(ReferenceInfo refInfo: refInfos) {
            if (refInfo.isExposedEndFirst()) {
                firstEndsExposed.add(refInfo);
            } else {
                secondEndsExposed.add(refInfo);
            }
        }
        
        boolean firstFirstEnd = true;
        for(ReferenceInfo refInfo: firstEndsExposed) {
            if (firstFirstEnd) {
                startConditionalBlock(CondType.IF, "firstEnd");
            }
            startConditionalBlock(
                firstFirstEnd ? CondType.IF : CondType.ELSEIF,
                QUOTE,
                refInfo.getBaseName(),
                QUOTE,
                ".equals(type)");
            assocMethodGenerator.generate(refInfo);
            firstFirstEnd = false;
        }
        if (!firstFirstEnd) {
            endBlock();
        }
        
        boolean firstSecondEnd = true;
        for(ReferenceInfo refInfo: secondEndsExposed) {
            if (firstSecondEnd) {
                if (firstFirstEnd) {
                    // No first ends
                    startConditionalBlock(CondType.IF, "!firstEnd");
                } else {
                    startConditionalBlock(CondType.ELSE);
                }
            }
            startConditionalBlock(
                firstSecondEnd ? CondType.IF : CondType.ELSEIF,
                QUOTE,
                refInfo.getBaseName(),
                QUOTE,
                ".equals(type)");
            assocMethodGenerator.generate(refInfo);
            firstSecondEnd = false;
        }
        if (!firstSecondEnd) {
            endBlock();
        }
        endBlock();
        
        newLine();
        generateThrowUnknownAssocTypeException();    
    }
    
    private void generateSetAssociationMethod(
        Collection<Reference> instanceReferences,
        Map<Reference, ReferenceInfo> refInfoMap,
        Collection<Association> unreferencedAssociations,
        Map<Association, ReferenceInfo> unrefAssocRefInfoMap)
    throws GenerationException
    {
        writeln("// Implement HibernateAssociable");
        startBlock(
            "public void setAssociation(String type, boolean firstEnd, ",
            ASSOCIATION_BASE_CLASS, " assoc)");

        List<ReferenceInfo> refInfos = 
            gatherRefInfos(
                instanceReferences,
                refInfoMap,
                unreferencedAssociations,
                unrefAssocRefInfoMap);
        
        generateGenericAssociationMethod(
            refInfos, 
            new AssocMethodGenerator() {
                public void generate(ReferenceInfo refInfo)
                    throws GenerationException
                {
                    writeln(
                        getReferenceMutatorName(refInfo),
                        "((",
                        makeType(refInfo.getKind()),
                        ")assoc);");
                    writeln("return;");
                }
            });
        
        endBlock();
    }

    private void generateGetOrCreateAssociationMethod(
        Collection<Reference> instanceReferences,
        Map<Reference, ReferenceInfo> refInfoMap,
        Collection<Association> unreferencedAssociations,
        Map<Association, ReferenceInfo> unrefAssocRefInfoMap)
    throws GenerationException
    {
        writeln("// Implement HibernateAssociable");
        startBlock(
            "public ",
            ASSOCIATION_BASE_CLASS,
            " getOrCreateAssociation(String type, boolean firstEnd)");

        List<ReferenceInfo> refInfos = 
            gatherRefInfos(
                instanceReferences,
                refInfoMap,
                unreferencedAssociations,
                unrefAssocRefInfoMap);
        
        generateGenericAssociationMethod(
            refInfos, 
            new AssocMethodGenerator() {
                public void generate(ReferenceInfo refInfo)
                    throws GenerationException
                {
                    startConditionalBlock(
                        CondType.IF,
                        getReferenceAccessorName(refInfo), "() == null");
                        
                    writeln(
                        makeType(refInfo.getKind()),
                        " assoc = new ",
                        makeType(refInfo.getKind()),
                        "();");
                    writeln("assoc.setType(type);");
                    
                    // Set up the local end of the association.
                    switch(refInfo.getKind()) {
                    case ONE_TO_ONE:
                        writeln(
                            "assoc.set",
                            getReferenceEndName(refInfo, false),
                            "(this);");
                        break;
                        
                    case ONE_TO_MANY:
                        boolean hasParent = refInfo.isSingle();
                        if (!hasParent) {
                            writeln("assoc.setParent(this);");
                        } else {
                            writeln("assoc.getChildren().add(this);");
                        }
                        writeln(
                            "assoc.setReversed(", refInfo.isSingle(1), ");");
                        break;

                    case MANY_TO_MANY:
                        writeln("assoc.setSource(this);");
                        writeln("assoc.setReversed(!firstEnd);");
                        break;
                    }
                    
                    writeln(getReferenceMutatorName(refInfo), "(assoc);");
                    writeln("assoc.save();");
                    endBlock();
                    writeln(
                        "return ", getReferenceAccessorName(refInfo), "();");
                } 
            });

        endBlock();
    }

    private void generateThrowUnknownAssocTypeException()
    {
        writeln(
            "throw new IllegalArgumentException(",
            QUOTE, "Unknown assoc type '", QUOTE,
            " + type + ", QUOTE, "' for 'end ", QUOTE,
            " + (firstEnd ? 1 : 2) + ", QUOTE, "'", QUOTE, ");");
    }

    private List<ReferenceInfo> gatherRefInfos(
        Collection<Reference> instanceReferences,
        Map<Reference, ReferenceInfo> refInfoMap,
        Collection<Association> unreferencedAssociations,
        Map<Association, ReferenceInfo> unrefAssocRefInfoMap)
    {
        List<ReferenceInfo> refInfos = new ArrayList<ReferenceInfo>();
        for(Reference ref: instanceReferences) {
            ReferenceInfo refInfo = refInfoMap.get(ref);
            refInfos.add(refInfo);
        }
        for(Association unrefAssociation: unreferencedAssociations) {
            ReferenceInfo refInfo = unrefAssocRefInfoMap.get(unrefAssociation);
            refInfos.add(refInfo);
        }
        return refInfos;
    }

    private void generateClassInstanceRefMethods(
        Collection<Reference> instanceReferences,
        Map<Reference, ReferenceInfo> refInfoMap)
        throws GenerationException
    {
        for(Reference ref: instanceReferences) {
            newLine();

            ReferenceInfo refInfo = refInfoMap.get(ref);
            if (refInfo == null) {
                throw new GenerationException(
                    "unknown reference '" + ref.getName() + "'");
            }
            
            switch(refInfo.getKind()) {
            case ONE_TO_ONE:
                generateClassInstanceRefOneToOneMethods(ref, refInfo);
                break;
            
            case ONE_TO_MANY: 
                generateClassInstanceRefOnetoManyMethods(ref, refInfo);
                break;
            
            case MANY_TO_MANY:
                generateClassInstanceRefManyToManyMethods(ref, refInfo);
                break;
                
            default:
                throw new GenerationException(
                    "Unknown reference type: " + refInfo.getKind());
            }

            generateClassInstanceAssocMethods(refInfo);
        }
    }

    private void generateClassInstanceAssocMethods(ReferenceInfo refInfo)
    {
        newLine();
        writeln("// Internal use only");
        startBlock(
            "public ",
            makeType(refInfo.getKind()),
            " ",
            getReferenceAccessorName(refInfo),
            "()");
        writeln("return ", refInfo.getFieldName(), ";");
        endBlock();

        newLine();
        writeln("// Internal use only");
        startBlock(
            "public void ",
            getReferenceMutatorName(refInfo),
            "(",
            makeType(refInfo.getKind()),
            " newValue)");
        writeln("this.", refInfo.getFieldName(), " = newValue;");
        endBlock();
    }

    private void generateClassInstanceRefOneToOneMethods(
        Reference ref,
        ReferenceInfo refInfo)
    {
        startAccessorBlock(ref);
        startConditionalBlock(
            CondType.IF,
            getReferenceAccessorName(refInfo), "() == null");
        writeln("return null;");
        endBlock();

        writeln(
            "return ", 
            getReferenceAccessorName(refInfo),
            "().get", getReferenceEndName(refInfo, true),
            "(",
            refInfo.getReferencedTypeName(),
            ".class",
            ");");
        endBlock();
        
        if (ref.isChangeable()) {
            newLine();
            startMutatorBlock(ref);
            
            writeln("// Get the existing association object");
            writeln(
                ASSOCIATION_BASE_CLASS,
                " assoc = getAssociation(",
                QUOTE, refInfo.getBaseName(), QUOTE,
                ", ",
                refInfo.isExposedEndFirst(),
                ");");
            startConditionalBlock(
                CondType.IF, "assoc == null && newValue != null");
            writeln(
                "// If none exists, get the new value's association.");
            writeln(
                "assoc = ((", 
                ASSOCIABLE_INTERFACE, 
                ")newValue).getAssociation(",
                QUOTE, refInfo.getBaseName(), QUOTE,
                ", ",
                !refInfo.isExposedEndFirst(), ");");
            endBlock();

            startConditionalBlock(CondType.IF, "assoc == null");
            startConditionalBlock(CondType.IF, "newValue == null");
            writeln(
                "// User is clearing a non-existent association: do nothing");
            writeln("return;");
            endBlock();
            writeln(
                "assoc = getOrCreateAssociation(",
                QUOTE, refInfo.getBaseName(), QUOTE,
                ", ",
                refInfo.isExposedEndFirst(),
                ");");
            endBlock();

            startConditionalBlock(CondType.IF, "newValue != null");
            if (refInfo.isExposedEndFirst()) {
                writeln(
                    "assoc.add(this, (", 
                    ASSOCIABLE_INTERFACE,
                    ")newValue);");
            } else {
                writeln(
                    "assoc.add((", 
                    ASSOCIABLE_INTERFACE,
                    ")newValue, this);");
            }
            startConditionalBlock(CondType.ELSE);
            writeln("// remove any existing association");
            writeln("assoc.removeAll(this);");
            endBlock();
            endBlock();                        
        }
    }

    private void generateClassInstanceRefOnetoManyMethods(
        Reference ref,
        ReferenceInfo refInfo)
    {
        startAccessorBlock(ref);
        boolean hasParent = ref.getMultiplicity().getUpper() == 1;
        if (hasParent) {
            startConditionalBlock(
                CondType.IF, 
                getReferenceAccessorName(refInfo), "() == null");
            writeln("return null;");
            endBlock();
            writeln(
                "return (",
                refInfo.getEndType(refInfo.isSingle(0) ? 0 : 1),                            
                ")", 
                getReferenceAccessorName(refInfo), 
                "().getParent();");
        } else {
            String listElemType = 
                refInfo.getEndType(refInfo.isSingle(0) ? 1 : 0);
            // TODO: Cache ListProxy in a field?
            startConditionalBlock(
                CondType.IF, 
                getReferenceAccessorName(refInfo), "() == null");
            writeln(
                "return new ", 
                LIST_PROXY_CLASS,
                "<", listElemType, ">",
                "(", QUOTE, refInfo.getBaseName(), QUOTE,
                ", ", refInfo.isExposedEndFirst(),
                ", this, ",
                listElemType, ".class);");
            startConditionalBlock(CondType.ELSE);
            writeln(
                "return new ",
                LIST_PROXY_CLASS,
                "<", listElemType, ">",
                "(",
                getReferenceAccessorName(refInfo),
                "(), this, ",
                refInfo.isExposedEndFirst(), ", ",
                listElemType, ".class);");
            endBlock();
        }
        endBlock();
        
        if (hasParent && ref.isChangeable()) {
            newLine();
            startMutatorBlock(ref);
            writeln("// get existing association, if any");
            writeln(
                ASSOCIATION_BASE_CLASS,
                " assoc = getAssociation(",
                QUOTE, refInfo.getBaseName(), QUOTE,
                ", ",
                refInfo.isExposedEndFirst(),
                ");");
            startConditionalBlock(
                CondType.IF, "assoc == null && newValue != null");
            writeln("// None exists, get the new value's association.");
            writeln(
                "assoc = ((", 
                ASSOCIABLE_INTERFACE, 
                ")newValue).getAssociation(",
                QUOTE, refInfo.getBaseName(), QUOTE,
                ", ",
                !refInfo.isExposedEndFirst(),
                ");");
            endBlock();

            startConditionalBlock(CondType.IF, "assoc == null");
            startConditionalBlock(CondType.IF, "newValue == null");
            writeln(
                "// User is clearing a non-existent association: do nothing");
            writeln("return;");
            endBlock();
            writeln(
                "assoc = getOrCreateAssociation(",
                QUOTE, refInfo.getBaseName(), QUOTE,
                ", ",
                refInfo.isExposedEndFirst(),
                ");");
            endBlock();

            startConditionalBlock(CondType.IF, "newValue != null");
            // NOTE: we don't cast to the "_Impl" type here 
            // because they do not inherit from each other
            // and there may be multiple implementations of
            // the parent interface.
            writeln(
                "assoc.add((",
                ASSOCIABLE_INTERFACE,
                ")newValue, this);");
            startConditionalBlock(CondType.ELSE);
            writeln("// remove any existing association");
            writeln("assoc.removeAll(this);");
            endBlock();
            endBlock();                        
        }
    }

    private void generateClassInstanceRefManyToManyMethods(
        Reference ref,
        ReferenceInfo refInfo)
    {
        startAccessorBlock(ref);
        String listElemType = 
            getReferenceEndType(refInfo, true);
        // TODO: Cache ListProxy in a field?
        startConditionalBlock(
            CondType.IF,
            getReferenceAccessorName(refInfo), "() == null");
        writeln(
            "return new ", 
            LIST_PROXY_CLASS, "<", listElemType, ">",
            "(", QUOTE, refInfo.getBaseName(), QUOTE,
            ", ", refInfo.isExposedEndFirst(),
            ", this, ",
            listElemType, ".class);");
        startConditionalBlock(CondType.ELSE);
        writeln(
            "return new ",
            LIST_PROXY_CLASS, "<", listElemType, ">",
            "(", 
            getReferenceAccessorName(refInfo), "(), this, ",
            refInfo.isExposedEndFirst(), ", ",
            listElemType, ".class);");
        endBlock();
        endBlock();
    }

    private void generateClassInstanceConstructors(
        MofClass cls,
        Collection<Attribute> instanceAttributes,
        ArrayList<Attribute> nonDerivedAttribs,
        Map<Attribute, String> nonDerivedAttribNames,
        Set<Attribute> nonDataTypeAttribs)
    {
        // zero argument constructor
        startConstructorBlock(cls, null, null, IMPL_SUFFIX);
        writeln("super();");
        for(Attribute attrib: nonDerivedAttribs) {
            MultiplicityType mult = attrib.getMultiplicity();
            int upper = mult.getUpper();
            if (upper == -1 || upper > 1) {
                // Multiple values -- initialize collection
                String fieldName = nonDerivedAttribNames.get(attrib);

                String suffix = null;
                if (nonDataTypeAttribs.contains(attrib)) {
                    suffix = IMPL_SUFFIX;
                }
                
                String elemTypeName = 
                    generator.getTypeName(attrib.getType(), suffix);
                
                String collTypeName;
                if (mult.isOrdered()) {
                    collTypeName = 
                        generator.getCollectionType(
                            ORDERED_COLLECTION_IMPL_CLASS, elemTypeName);
                } else {
                    collTypeName = 
                        generator.getCollectionType(
                            COLLECTION_IMPL_CLASS, elemTypeName);
                }
                
                writeln(
                    "this.",
                    fieldName,
                    " = new ",
                    collTypeName,
                    "();");
            }
        }
        endBlock();
        
        if (instanceAttributes.size() ==  0) {
            return;
        }

        // constructor
        newLine();
        ModelElement[] params = 
            nonDerivedAttribs.toArray(
                new ModelElement[nonDerivedAttribs.size()]);
        startConstructorBlock(cls, params, IMPL_SUFFIX);
        writeln("this();");
        for(Attribute attrib: nonDerivedAttribs) {
            String fieldName = nonDerivedAttribNames.get(attrib);
            String[] paramInfo = generator.getParam(attrib);
            boolean isNonDataType = 
                nonDataTypeAttribs.contains(attrib);
            MultiplicityType mult = attrib.getMultiplicity();
            int upper = mult.getUpper();
            if (upper == -1 || upper > 1) {
                // Copy the collection
                if (isNonDataType) {
                    boolean isOrdered = mult.isOrdered();
                    String elemTypeName = 
                        generator.getTypeName(attrib.getType(), IMPL_SUFFIX);
                    String asClause = 
                        isOrdered ? "asTypedList" : "asTypedCollection";
                    writeln(
                        "this.",
                        fieldName,
                        ".addAll(",
                        GENERIC_COLLECTIONS_CLASS,
                        ".", asClause, "(",
                        paramInfo[1], ",",
                        elemTypeName, ".class));");
                } else {
                    writeln(
                        "this.",
                        fieldName,
                        ".addAll(",
                        paramInfo[1],
                        ");");
                }
            } else {
                if (isNonDataType) {
                    writeln(
                        "this.",
                        fieldName,
                        " = (",
                        generator.getTypeName(attrib.getType(), IMPL_SUFFIX),
                        ")",
                        paramInfo[1],
                        ";");                            
                } else {
                    writeln(
                        "this.",
                        fieldName,
                        " = ",
                        paramInfo[1],
                        ";");
                }
            }       
        }
        endBlock();
    }

    private void generateClassInstanceAttribMethods(
        Collection<Attribute> instanceAttributes,
        Map<Attribute, String> nonDerivedAttribNames,
        Set<Attribute> entityTypeAttribs)
    {
        for(Attribute attrib: instanceAttributes) {
            String fieldName = nonDerivedAttribNames.get(attrib);
            if (fieldName == null) {
                throw new UnsupportedOperationException(
                    "derived attributes not supported");
            }
            
            boolean isEntityType = entityTypeAttribs.contains(attrib);
            String suffix = isEntityType ? IMPL_SUFFIX : null;
            
            int upper = attrib.getMultiplicity().getUpper();
            if (upper == 1) {
                newLine();
                startAccessorBlock(attrib, suffix, suffix);
                writeln("return ", fieldName, ";");
                endBlock();
                
                newLine();
                startMutatorBlock(attrib, suffix, suffix);
                
                // REVIEW: SWZ: 12/31/07: Some attributes are not 
                // changeable, but Hibernate will still use this method to
                // set the value at load time.  This method isn't in the
                // class instance interface, but perhaps there's a way to
                // detect user invocation and throw an exception.
                writeln("this.", fieldName, " = newValue;");
                endBlock();                        
            } else if (upper != 0) {
                newLine();
                startAccessorBlock(attrib, suffix, suffix);
                
                if (attrib.isChangeable()) {
                    writeln("return ", fieldName, ";");
                } else {
                    if (attrib.getMultiplicity().isOrdered()) {
                        writeln(
                            "return ", 
                            JAVA_UTIL_COLLECTIONS_CLASS, 
                            ".unmodifiableList(", 
                            fieldName,
                            ");");
                    } else {
                        writeln(
                            "return ",
                            JAVA_UTIL_COLLECTIONS_CLASS, 
                            ".unmodifiableSet(",
                            fieldName,
                            ");");                            
                    }
                }
                endBlock();
            }
            
            if (!isEntityType) {
                continue;
            }
            
            // Go back and implement the interface methods in terms
            // of the attribute's interface type (as opposed to the
            // concrete type)
            if (upper == 1) {
                newLine();
                startAccessorBlock(attrib);
                writeln(
                    "return ",
                    generator.getAccessorName(attrib), 
                    IMPL_SUFFIX,
                    "();");
                endBlock();
                
                if (attrib.isChangeable()) {
                    newLine();
                    startMutatorBlock(attrib);
                    writeln(
                        generator.getMutatorName(attrib), IMPL_SUFFIX,
                        "((",
                        generator.getTypeName(attrib.getType(), IMPL_SUFFIX),
                        ")newValue);");
                    endBlock();                        
                }
            } else if (upper != 0) {
                newLine();
                startAccessorBlock(attrib);
                
                String asClause = 
                    attrib.getMultiplicity().isOrdered()
                        ? "asTypedList"
                        : "asTypedCollection";
                writeln(
                    "return ",
                    GENERIC_COLLECTIONS_CLASS,
                    ".", asClause, "(", 
                    generator.getAccessorName(attrib), IMPL_SUFFIX,
                    ", ",
                    generator.getTypeName(attrib.getType()),
                    ".class);");
                endBlock();
            }
        }
    }

    public void generateClassProxy(MofClass cls)
        throws GenerationException
    {
        if (HibernateCodeGenUtils.isTransient(cls)) {
            if (getPassIndex() < numTransientPasses) {
                log.fine("Delegating Transient Class Proxy Implementation");
                transientHandler.generateClassProxy(cls);
            }
            return;
        }

        if (checkPassIndex(1)) {
            return;
        }
        
        String interfaceName = generator.getTypeName(cls, CLASS_PROXY_SUFFIX);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        String instanceInterfaceTypeName = generator.getTypeName(cls);
        String instanceImplTypeName = generator.getTypeName(cls, IMPL_SUFFIX);
        
        log.fine("Generating Class Proxy Implementation '" + typeName + "'");

        open(typeName);
        try {
            writeClassHeader(
                cls,
                typeName, 
                REF_CLASS_IMPL_CLASS.toString(),
                new String[] { interfaceName }, 
                JavaClassReference.computeImports(METAMODEL_INITIALIZER_CLASS),
                false,
                CLASS_PROXY_IMPL_COMMENT);
            
            String classIdentifier = getClassIdentifier(cls);
            writeConstant(
                "String", "_id", "\"" + classIdentifier + "\"", true);
            newLine();
            
            startConstructorBlock(
                cls,
                new String[] { REF_PACKAGE_CLASS.toString() },
                new String[] { "container" },
                true,
                CLASS_PROXY_SUFFIX + IMPL_SUFFIX);
            if (cls.isAbstract()) {
                writeln(
                    "super(container, null, ",
                    instanceInterfaceTypeName, ".class);");                
            } else {
                writeln(
                    "super(container, ",
                    instanceImplTypeName, ".class, ",
                    instanceInterfaceTypeName, ".class);");
            }
            
            newLine();
            writeln(
                METAMODEL_INITIALIZER_CLASS,
                ".getCurrentInitializer().setRefMetaObject(this, ", 
                QUOTE, cls.getName(), QUOTE, ");");
            
            endBlock();
            
            if (!cls.isAbstract()) {
                // No-arg factory method
                newLine();
                startCreatorBlock(cls, null, "");
                String entityImplName = 
                    generator.getSimpleTypeName(cls, IMPL_SUFFIX);
                writeln(
                    entityImplName,
                    " obj = new ", instanceImplTypeName, "();");
                writeln("obj.save();");
                writeln("return obj;");
                endBlock();
                
                Collection<Attribute> allAttributes =
                    contentsOfType(
                        cls, 
                        HierachySearchKindEnum.INCLUDE_SUPERTYPES, 
                        ScopeKindEnum.INSTANCE_LEVEL,
                        Attribute.class);
                for(Iterator<Attribute> i = allAttributes.iterator(); 
                    i.hasNext(); ) 
                {
                    Attribute attrib = i.next();
                    
                    if (attrib.isDerived()) {
                        i.remove();
                    }
                }
                
                // factory method                
                if (allAttributes.size() > 0) {
                    newLine();
                    
                    ModelElement[] params = 
                        allAttributes.toArray(
                            new ModelElement[allAttributes.size()]);
                    startCreatorBlock(cls, params, "");  
                    writeln(
                        entityImplName,
                        " obj = new ",
                        instanceImplTypeName,
                        "(");
                    increaseIndent();
                    for(Iterator<Attribute> i = allAttributes.iterator(); 
                        i.hasNext(); ) 
                    {
                        Attribute attrib = i.next();
                        
                        String[] paramInfo = generator.getParam(attrib);

                        writeln(paramInfo[1], i.hasNext() ? "," : ");");
                    }
                    decreaseIndent();
                    writeln("obj.save();");
                    writeln("return obj;");
                    endBlock();
                }
            }

            newLine();
            startBlock("protected String getClassIdentifier()");
            writeln("return _id;");
            endBlock();
            
            writeEntityFooter();
        }
        finally {
            close();
        }
    }
    
    public void generatePackage(MofPackage pkg)
        throws GenerationException
    {
        if (HibernateCodeGenUtils.isTransient(pkg)) {
            if (getPassIndex() < numTransientPasses) {
                log.fine("Delegating Transient Package Implementation");
                transientHandler.generatePackage(pkg);
            }
            return;
        }

        if (checkPassIndex(1)) {
            return;
        }
        
        String interfaceName = 
            generator.getTypeName(pkg, PACKAGE_SUFFIX);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        log.fine("Generating Package Implementation '" + typeName + "'");

        open(typeName);
        try {
            writeClassHeader(
                pkg,
                typeName, 
                REF_PACKAGE_IMPL_CLASS.toString(),
                new String[] { interfaceName }, 
                JavaClassReference.computeImports(METAMODEL_INITIALIZER_CLASS),
                false,
                PACKAGE_IMPL_COMMENT);
            
            // Generate fields for all nested packages, class proxies and
            // associations.
            
            ArrayList<String> packageFieldNames = new ArrayList<String>();
            Collection<MofPackage> packages =
                contentsOfType(pkg, MofPackage.class);
            boolean hasPackages = !packages.isEmpty();
            if (hasPackages) {
                writeln("// Packages");
            }
            for(MofPackage nestedPkg: packages) {
                String fieldName = 
                    writePrivateField(
                        nestedPkg, true, false, PACKAGE_SUFFIX);
                packageFieldNames.add(fieldName);
            }
            
            ArrayList<String> classFieldNames = new ArrayList<String>();
            Collection<MofClass> classes = contentsOfType(pkg, MofClass.class);
            boolean hasClasses = !classes.isEmpty();
            if (hasClasses) {
                if (hasPackages) {
                    newLine();
                }
                writeln("// Class Proxies");
            }
            for(MofClass cls: classes) {
                String fieldName =
                    writePrivateField(
                        cls, true, false, CLASS_PROXY_SUFFIX);
                classFieldNames.add(fieldName);
            }
            
            ArrayList<String> assocFieldNames = new ArrayList<String>();
            Collection<Association> assocs = 
                contentsOfType(pkg, Association.class);
            boolean hasAssocs = !assocs.isEmpty();
            if (hasAssocs) {
                if (hasPackages || hasClasses) {
                    newLine();
                }
                writeln("// Associations");
            }
            for(Association assoc: assocs) {
                String fieldName =
                    writePrivateField(assoc, true, false, "");
                assocFieldNames.add(fieldName);
            }
            newLine();
            
            // constructor (initializes fields)       
            startBlock(
                "public ",
                generator.getSimpleTypeName(pkg, PACKAGE_SUFFIX + IMPL_SUFFIX),
                "(",
                REF_PACKAGE_CLASS.toString(), " container)");
            writeln("super(container);");

            newLine();
            writeln(
                METAMODEL_INITIALIZER_CLASS,
                ".getCurrentInitializer().setRefMetaObject(this, ", 
                QUOTE, pkg.getName(), QUOTE, ");");
            
            if (hasPackages) {
                newLine();
            }
            // initialize nested package fields
            Iterator<String> nameIter;
            Iterator<MofPackage> pkgIter;
            for(
                nameIter = packageFieldNames.iterator(),
                    pkgIter = packages.iterator();
                nameIter.hasNext() && pkgIter.hasNext(); )
            {
                writeln(
                    "this.",
                    nameIter.next(),
                    " = new ",
                    generator.getTypeName(
                        pkgIter.next(), PACKAGE_SUFFIX + IMPL_SUFFIX),
                    "(this);");
            }
            
            // initialize class proxy fields 
            if (hasClasses && hasPackages) {
                newLine();
            }
            
            Iterator<MofClass> clsIter;
            for(
                nameIter = classFieldNames.iterator(),
                    clsIter = classes.iterator();
                nameIter.hasNext() && clsIter.hasNext(); )
            {
                writeln(
                    "this.",
                    nameIter.next(),
                    " = new ",
                    generator.getTypeName(
                        clsIter.next(), CLASS_PROXY_SUFFIX + IMPL_SUFFIX),
                    "(this);");
            }

            // initialize association fields
            if (hasAssocs && 
                (hasPackages || hasClasses))
            {
                newLine();
            }
            
            Iterator<Association> assocIter;
            for(
                nameIter = assocFieldNames.iterator(),
                    assocIter = assocs.iterator();
                nameIter.hasNext() && assocIter.hasNext(); )
            {
                writeln(
                    "this.",
                    nameIter.next(),
                    " = new ",
                    generator.getTypeName(assocIter.next(), IMPL_SUFFIX),
                    "(this);");
            }
            
            endBlock();
            newLine();
            
            // generate accessor methods

            if (hasPackages) {
                writeln("// Package Accessors");
                newLine();
            }

            // package accessors
            for(
                nameIter = packageFieldNames.iterator(),
                    pkgIter = packages.iterator();
                nameIter.hasNext() && pkgIter.hasNext(); )
            {
                MofPackage nestedPkg = pkgIter.next();
                startPackageAccessorBlock(nestedPkg, PACKAGE_SUFFIX);
                
                writeln("return ", nameIter.next(), ";");                

                endBlock();
                newLine();
            }
            
            // class proxy accessors
            if (hasClasses) {
                if (hasPackages) {
                    newLine();
                }
                writeln("// Class Proxy Accessors");
                newLine();
            }
            
            for(
                nameIter = classFieldNames.iterator(),
                    clsIter = classes.iterator();
                nameIter.hasNext() && clsIter.hasNext(); )
            {
                MofClass cls = clsIter.next();
                startPackageAccessorBlock(cls, CLASS_PROXY_SUFFIX);
                
                writeln("return ", nameIter.next(), ";");
                
                endBlock();
                newLine();
            }

            // association accessors
            if (hasAssocs) {
                if (hasPackages || hasClasses) {
                    newLine();
                }
                writeln("// Association Accessors");
                newLine();
            }
            for(
                nameIter = assocFieldNames.iterator(),
                    assocIter = assocs.iterator();
                nameIter.hasNext() && assocIter.hasNext(); )
            {
                Association assoc = assocIter.next();
                startPackageAccessorBlock(assoc, "");
                
                writeln("return ", nameIter.next(), ";");
                
                endBlock();
                newLine();
            }
            
            writeEntityFooter();
        }
        finally {
            close();
        }
    }
    
    private boolean checkPassIndex(int min) throws GenerationException
    {
        int passIndex = getPassIndex();
        if (passIndex < min || passIndex >= numPasses) {
            return true;
        }
        
        return false;
    }
    
    private String getClassIdentifier(MofClass cls) throws GenerationException
    {
        if (classIdentifierMap.containsKey(cls)) {
            return classIdentifierMap.get(cls);
        }

        try {
            MessageDigest sha1md = MessageDigest.getInstance("SHA-1");
            
            // All super types, in hierarchical order
            List<MofClass> clsHierarchy = new ArrayList<MofClass>();
            clsHierarchy.add(cls);
            for(int i = 0; i < clsHierarchy.size(); i++) {
                MofClass type = clsHierarchy.get(i);
                
                clsHierarchy.addAll(
                    GenericCollections.asTypedList(
                        type.getSupertypes(), MofClass.class));
                
                String superTypeName = generator.getTypeName(type);
                sha1md.update(superTypeName.getBytes());
            }
            
            for(MofClass type: clsHierarchy) {
                for(Attribute attrib: 
                        contentsOfType(
                            type, 
                            HierachySearchKindEnum.ENTITY_ONLY,
                            VisibilityKindEnum.PUBLIC_VIS,
                            Attribute.class)) 
                {
                    String attribType = generator.getTypeName(attrib);
                    String attribName = attrib.getName();
                    
                    sha1md.update(attribType.getBytes());
                    sha1md.update(attribName.getBytes());
                }

                for(Reference ref: 
                    contentsOfType(
                        type, 
                        HierachySearchKindEnum.ENTITY_ONLY,
                        VisibilityKindEnum.PUBLIC_VIS,
                        Reference.class)) 
                {
                    String attribType = generator.getTypeName(ref);
                    String attribName = ref.getName();
                    
                    sha1md.update(attribType.getBytes());
                    sha1md.update(attribName.getBytes());
                }
            }
            
            byte[] digest = sha1md.digest();
            
            StringBuffer digestStrBuf = new StringBuffer();
            for(int i = 0; i < digest.length; i++) {
                String digestByteStr = 
                    Integer.toHexString((int)digest[i] & 0xFF);
                if (digestByteStr.length() < 2) {
                    digestStrBuf.append('0');
                }
                digestStrBuf.append(digestByteStr);
            }
            
            String digestStr = digestStrBuf.toString();
            classIdentifierMap.put(cls, digestStr);
            return digestStr;
        } catch (NoSuchAlgorithmException e) {
            throw new GenerationException(e);
        }
    }
    
    private String makeType(AssociationKindEnum kind)
    {
        switch(kind)
        {
        case ONE_TO_ONE:
            return ASSOCIATION_ONE_TO_ONE_IMPL_CLASS.toString();
            
        case ONE_TO_MANY:
            return ASSOCIATION_ONE_TO_MANY_IMPL_CLASS.toString();            

        case MANY_TO_MANY:
            return ASSOCIATION_MANY_TO_MANY_IMPL_CLASS.toString();
        }
        
        throw new IllegalArgumentException(
            "Unknown AssociationKindEnum: " + kind);
    }
    
    private String getReferenceEndName(
        ReferenceInfo refInfo, boolean isRefEnd)
    {
        int index = 
            isRefEnd
                ? refInfo.getReferencedEndIndex()
                : refInfo.getExposedEndIndex();
        assert(index >= 0 && index <= 1);

        switch(refInfo.getKind()) {
        case ONE_TO_ONE:
            return index == 0 ? "Parent" : "Child";
            
        case ONE_TO_MANY:
            if (refInfo.isSingle(index)) {
                return "Parent";
            } else {
                return "Children";
            }
            
        case MANY_TO_MANY:
            return "Target";
        }

        throw new IllegalArgumentException(
            "Unknown AssociationKindEnum: " + refInfo.getKind());
    }
    
    private String getReferenceEndType(
        ReferenceInfo refInfo, boolean isRefEnd)
    {
        int index = 
            isRefEnd
                ? refInfo.getReferencedEndIndex()
                : refInfo.getExposedEndIndex();
        assert(index >= 0 && index <= 1);

        return refInfo.getEndType(index);
    }
    
    private String getReferenceAccessorName(ReferenceInfo refInfo)
    {
        return "get" + refInfo.getReferencedEndBaseName() + IMPL_SUFFIX;
    }

    private String getReferenceMutatorName(ReferenceInfo refInfo)
    {
        return "set" + refInfo.getReferencedEndBaseName() + IMPL_SUFFIX;
    }
    
    private String makeType(AssociationInfo assocInfo)
    {
        StringBuffer type = new StringBuffer();
        switch(assocInfo.getKind()) {
        case ONE_TO_ONE:
            type.append(REF_ASSOCIATION_ONE_TO_ONE_IMPL_CLASS);
            break;
            
        case ONE_TO_MANY:
            type.append(REF_ASSOCIATION_ONE_TO_MANY_IMPL_CLASS);
            break;
            
        case MANY_TO_MANY:
            type.append(REF_ASSOCIATION_MANY_TO_MANY_IMPL_CLASS);
            break;

        default:
            throw new IllegalArgumentException(
                "Unknown AssociationKindEnum: " + assocInfo.getKind());
        }

        type
            .append("<")
            .append(assocInfo.getEndType(0))
            .append(", ")
            .append(assocInfo.getEndType(1))
            .append(">");

        return type.toString();
    }
    
    private static class MofClassAttribPair
    {
        private final MofClass cls;
        private final Attribute attrib;
        
        private MofClassAttribPair(MofClass cls, Attribute attrib)
        {
            this.cls = cls;
            this.attrib = attrib;
        }
        
        public boolean equals(Object o)
        {
            MofClassAttribPair that = (MofClassAttribPair)o;
            
            return 
                this.cls.equals(that.cls) && 
                this.attrib.equals(that.attrib);
        }
        
        public int hashCode()
        {
            return cls.hashCode() ^ attrib.hashCode();
        }
    }
    
    private static interface AssocMethodGenerator
    {
        public void generate(ReferenceInfo refInfo) throws GenerationException;
    }
}

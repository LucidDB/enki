/*
// $Id$
// Enki generates and implements the JMI and MDR APIs for MOF metamodels.
// Copyright (C) 2007-2007 The Eigenbase Project
// Copyright (C) 2007-2007 Disruptive Tech
// Copyright (C) 2007-2007 LucidEra, Inc.
//
// This library is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or (at
// your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/
package org.eigenbase.enki.hibernate.codegen;

import java.util.*;
import java.util.logging.*;

import javax.jmi.model.*;
import javax.jmi.reflect.*;

import org.eigenbase.enki.codegen.*;
import org.eigenbase.enki.codegen.Generator.*;
import org.eigenbase.enki.hibernate.jmi.*;
import org.eigenbase.enki.hibernate.storage.*;

/**
 * HibernateJavaHandler generates Java implementations for the JMI/MOF
 * interfaces generated by the {@link JmiTemplateHandler default code 
 * generation}.
 *  
 * @author Stephan Zuercher
 */
public class HibernateJavaHandler
    extends JavaHandlerBase
    implements 
        AssociationHandler, 
        ClassInstanceHandler, 
        ClassProxyHandler,
        PackageHandler
{
    // REVIEW: SWZ: 11/7/2007: Relies on JmiTemplateHandler to throw
    // for cases (e.g., Import, StructureType) that we don't handle.    

    
    /** 
     * Suffix for implementation class names and association implementation
     * methods.
     */
    public static final String IMPL_SUFFIX = "_Impl";

    /**
     * Name of the base class for classes that implement {@link RefObject}.
     */
    public static final JavaClassReference REF_OBJECT_IMPL_CLASS = 
        new JavaClassReference(HibernateRefObject.class);

    /**
     * Name of the base class for classes that implement {@link RefClass}.
     */
    public static final JavaClassReference REF_CLASS_IMPL_CLASS = 
        new JavaClassReference(HibernateRefClass.class);
    
    /**
     * Name of the base class for classes that implement {@link RefPackage}.
     */
    public static final JavaClassReference REF_PACKAGE_IMPL_CLASS = 
        new JavaClassReference(HibernateRefPackage.class);

    /**
     * Name of the base class for classes that implement {@link RefAssociation}
     * for one-to-many associations.
     */
    public static final JavaClassReference REF_ASSOCIATION_ONE_TO_MANY_IMPL_CLASS = 
        new JavaClassReference(HibernateOneToManyRefAssociation.class);

    /**
     * Name of the base class for classes that implement {@link RefAssociation}
     * for one-to-one associations.
     */
    public static final JavaClassReference REF_ASSOCIATION_ONE_TO_ONE_IMPL_CLASS =
        new JavaClassReference(HibernateOneToOneRefAssociation.class);
    
    /**
     * Name of the base class for classes that implement {@link RefAssociation}
     * for many-to-many associations.
     */
    public static final JavaClassReference REF_ASSOCIATION_MANY_TO_MANY_IMPL_CLASS =
        new JavaClassReference(HibernateManyToManyRefAssociation.class);
    
    /**
     * Name of the base class for stored objects.
     */
    public static final JavaClassReference OBJECT_IMPL_CLASS = 
        new JavaClassReference(HibernateObject.class, true);
    
    /**
     * Name of the base class for stored objects that are participants in one 
     * or more types of Association.
     */
    public static final JavaClassReference ASSOCIABLE_INTERFACE = 
        new JavaClassReference(HibernateAssociable.class, true);

    /**
     * Name of the base class for all associations.
     */
    public static final JavaClassReference ASSOCIATION_BASE_CLASS = 
        new JavaClassReference(HibernateAssociation.class, true);
    
    /**
     * Name of the class for one-to-one associations.
     */
    public static final JavaClassReference ASSOCIATION_ONE_TO_ONE_IMPL_CLASS = 
        new JavaClassReference(HibernateOneToOneAssociation.class, true);
    
    /**
     * Name of the class for one-to-many associations.
     */
    public static final JavaClassReference ASSOCIATION_ONE_TO_MANY_IMPL_CLASS = 
        new JavaClassReference(HibernateOneToManyAssociation.class, true);
    
    /**
     * Name of the class for many-to-many associations.
     */
    public static final JavaClassReference ASSOCIATION_MANY_TO_MANY_IMPL_CLASS = 
        new JavaClassReference(HibernateManyToManyAssociation.class, true);

    private static final JavaClassReference LIST_PROXY_CLASS = 
        new JavaClassReference(ListProxy.class, true);
    
    /** Class comment for {@link RefPackage} implementations. */
    private static final String PACKAGE_IMPL_COMMENT = 
        "{0} package implementation.";

    /** Class comment for {@link RefClass} implementations. */
    private static final String CLASS_PROXY_IMPL_COMMENT = 
        "{0} class proxy implementation.";

    /** Class comment for {@link RefAssociation} implementations. */
    private static final String ASSOC_IMPL_COMMENT = 
        "{0} association implementation.";

    /**
     * Name of the class used to stored unordered collections of attributes.
     */
    private static final JavaClassReference COLLECTION_IMPL_CLASS = 
        new JavaClassReference(HashSet.class);

    /**
     * Name of the class used to stored ordered collections of attributes.
     */
    private static final JavaClassReference ORDERED_COLLECTION_IMPL_CLASS = 
        new JavaClassReference(ArrayList.class);

    private static final JavaClassReference[] CLASS_INSTANCE_REFS = {
        OBJECT_IMPL_CLASS,
        ASSOCIABLE_INTERFACE,
        ASSOCIATION_BASE_CLASS,
        ASSOCIATION_ONE_TO_ONE_IMPL_CLASS,        
        ASSOCIATION_ONE_TO_MANY_IMPL_CLASS,
        ASSOCIATION_MANY_TO_MANY_IMPL_CLASS,
        LIST_PROXY_CLASS,
    };
    
    private final Logger log = 
        Logger.getLogger(HibernateJavaHandler.class.getName());

    public void generateAssociation(Association assoc)
        throws GenerationException
    {
        String interfaceName = generator.getTypeName(assoc);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        log.fine("Generating Association Implementation '" + typeName + "'");

        AssociationInfo assocInfo = new AssociationInfo(generator, assoc);
        
        open(typeName);
        try {
            String superClass;
            boolean end0Single = assocInfo.isSingle(0);
            boolean end1Single = assocInfo.isSingle(1);
            
            superClass = assocInfo.makeType(true);
            
            writeClassHeader(
                assoc,
                typeName, 
                superClass,
                new String[] { interfaceName }, 
                false,
                ASSOC_IMPL_COMMENT);
        
            // exists
            startGenericMethodBlock(
                assoc,
                "boolean",
                "exists", 
                assocInfo.types,
                assocInfo.names);
            writeln(
                "return super.exists(", 
                assocInfo.names[0],
                ", ",
                assocInfo.names[1], ");");
            endBlock();
            newLine();
            
            // get end1 from end2
            if (assocInfo.ends[0].isNavigable()) {
                boolean ordered = assocInfo.isOrdered(0);
                startGenericMethodBlock(
                    assoc,
                    end0Single 
                        ? assocInfo.types[0]
                        : generator.getCollectionType(
                            ordered 
                                ? JmiTemplateHandler.ORDERED_COLLECTION_CLASS
                                : JmiTemplateHandler.COLLECTION_CLASS,
                            assocInfo.types[0]),
                    generator.getAccessorName(assocInfo.ends[0], null),
                    new String[] { assocInfo.types[1] },
                    new String[] { assocInfo.names[1] });
                switch(assocInfo.kind) {
                case ONE_TO_ONE:
                case ONE_TO_MANY:
                    writeln("return getParentOf(", assocInfo.names[1], ");");
                    break;
                    
                case MANY_TO_MANY:
                    writeln("return getLeftOf(", assocInfo.names[1], ");");
                }
                endBlock();
                newLine();
            }
            
            // get end2 from end1
            if (assocInfo.ends[1].isNavigable()) {
                boolean ordered = assocInfo.isOrdered(1);
                startGenericMethodBlock(
                    assoc,
                    end1Single 
                        ? assocInfo.types[1]
                        : generator.getCollectionType(
                            ordered 
                                ? JmiTemplateHandler.ORDERED_COLLECTION_CLASS
                                : JmiTemplateHandler.COLLECTION_CLASS,
                            assocInfo.types[1]),
                    generator.getAccessorName(assocInfo.ends[1], null),
                    new String[] { assocInfo.types[0] },
                    new String[] { assocInfo.names[0] });
                switch(assocInfo.kind) {
                case ONE_TO_ONE:
                    writeln("return getChildOf(", assocInfo.names[0], ");");
                    break;

                case ONE_TO_MANY:
                    writeln("return getChildrenOf(", assocInfo.names[0], ");");
                    break;
                    
                case MANY_TO_MANY:
                    writeln("return getRightOf(", assocInfo.names[0], ");");
                }
                endBlock();
                newLine();
            }

            if (assocInfo.isChangeable(0) && assocInfo.isChangeable(1)) {
                // add
                startGenericMethodBlock(
                    assoc,
                    "boolean",
                    "add",
                    assocInfo.types,
                    assocInfo.names);
                writeln(
                    "return super.add(",
                    assocInfo.names[0],
                    ", ",
                    assocInfo.names[1],
                    ");");
                endBlock();

                newLine();
                
                // remove
                startGenericMethodBlock(
                    assoc,
                    "boolean",
                    "remove",
                    assocInfo.types,
                    assocInfo.names);
                writeln(
                    "return super.remove(",
                    assocInfo.names[0],
                    ", ",
                    assocInfo.names[1],
                    ");");
                endBlock();
            }
            
            writeEntityFooter();
        }
        finally {
            close();
        }            
    }

    public void generateClassInstance(MofClass cls)
        throws GenerationException
    {
        String interfaceName = generator.getTypeName(cls);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        if (cls.isAbstract()) {
            log.fine(
                "Skipping Class Instance Implementation '" + typeName + "'");
            return;
        }
        
        log.fine(
            "Generating Class Instance Implementation '" + typeName + "'");

        Collection<Reference> instanceReferences =
            contentsOfType(
                cls,
                HierachySearchKindEnum.INCLUDE_SUPERTYPES, 
                VisibilityKindEnum.PUBLIC_VIS,
                Reference.class);

        open(typeName);
        try {            
            String[] interfaces;
            if (instanceReferences.isEmpty()) {
                interfaces = new String[] { interfaceName };
            } else {
                interfaces = new String[] { 
                    interfaceName, ASSOCIABLE_INTERFACE.toString()
                };
            }
            
            writeClassHeader(
                cls, 
                typeName,
                REF_OBJECT_IMPL_CLASS.toString(),
                interfaces,
                JavaClassReference.computeImports(CLASS_INSTANCE_REFS),
                false,
                CLASS_COMMENT);
            
            // fields
            writeln("// Attribute Fields");
            Collection<Attribute> instanceAttributes =
                contentsOfType(
                    cls,
                    HierachySearchKindEnum.INCLUDE_SUPERTYPES, 
                    VisibilityKindEnum.PUBLIC_VIS,
                    ScopeKindEnum.INSTANCE_LEVEL,
                    Attribute.class);
            ArrayList<Attribute> nonDerivedAttribs = 
                new ArrayList<Attribute>();
            Map<Attribute, String> nonDerivedAttribNames = 
                new HashMap<Attribute, String>();
            for(Attribute attrib: instanceAttributes) {
                if (attrib.isDerived()) {
                    continue;
                }
                
                nonDerivedAttribs.add(attrib);
                
                String fieldName = writePrivateField(attrib, false, false);
                nonDerivedAttribNames.put(attrib, fieldName);
            }
            newLine();
            
            // reference fields
            writeln("// Reference Fields");
            Map<Reference, AssociationInfo> refInfo =
                new HashMap<Reference, AssociationInfo>();
            
            for(Reference ref: instanceReferences) {
                Association assoc = 
                    (Association)ref.getExposedEnd().getContainer();
                AssociationInfo assocInfo = 
                    new AssociationInfo(generator, assoc);
                
                writePrivateField(
                    assocInfo.makeType(false),
                    assocInfo.fieldName, 
                    false, 
                    false);

                refInfo.put(ref, assocInfo);
            }
            newLine();
            
            // zero-arg constructor
            startConstructorBlock(cls, null, null, IMPL_SUFFIX);
            writeln("super();");
            for(Attribute attrib: nonDerivedAttribs) {
                MultiplicityType mult = attrib.getMultiplicity();
                int upper = mult.getUpper();
                if (upper == -1 || upper > 1) {
                    // Multiple values -- initialize collection
                    String fieldName = nonDerivedAttribNames.get(attrib);

                    String elemTypeName = 
                        generator.getTypeName(attrib.getType());
                    
                    String collTypeName;
                    if (mult.isOrdered()) {
                        collTypeName = 
                            generator.getCollectionType(
                                ORDERED_COLLECTION_IMPL_CLASS, elemTypeName);
                    } else {
                        collTypeName = 
                            generator.getCollectionType(
                                COLLECTION_IMPL_CLASS, elemTypeName);
                    }
                    
                    writeln(
                        "this.",
                        fieldName,
                        " = new ",
                        collTypeName,
                        "();");
                }
            }
            endBlock();
            
            // constructor
            if (instanceAttributes.size() > 0) {
                newLine();
                ModelElement[] params = 
                    nonDerivedAttribs.toArray(
                        new ModelElement[nonDerivedAttribs.size()]);
                startConstructorBlock(cls, params, IMPL_SUFFIX);
                writeln("this();");
                for(Attribute attrib: nonDerivedAttribs) {
                    String fieldName = nonDerivedAttribNames.get(attrib);
                    String[] paramInfo = generator.getParam(attrib);
                    MultiplicityType mult = attrib.getMultiplicity();
                    int upper = mult.getUpper();
                    if (upper == -1 || upper > 1) {
                        // Copy the collection
                        writeln(
                            "this.",
                            fieldName,
                            ".addAll(",
                            paramInfo[1],
                            ");");
                    } else {
                        writeln(
                            "this.",
                            fieldName,
                            " = ",
                            paramInfo[1],
                            ";");
                    }       
                }
                endBlock();
            }
            
            // attribute methods
            for(Attribute attrib: instanceAttributes) {
                String fieldName = nonDerivedAttribNames.get(attrib);
                if (fieldName == null) {
                    throw new UnsupportedOperationException(
                        "derived attributes not supported");
                }

                int upper = attrib.getMultiplicity().getUpper();
                if (upper == 1) {
                    newLine();
                    startAccessorBlock(attrib);
                    writeln("return ", fieldName, ";");
                    endBlock();
                    
                    if (attrib.isChangeable()) {
                        newLine();
                        startMutatorBlock(attrib);
                        writeln("this.", fieldName, " = newValue;");
                        endBlock();                        
                    }
                } else if (upper != 0) {
                    newLine();
                    startAccessorBlock(attrib);
                    
                    if (attrib.isChangeable()) {
                        writeln("return ", fieldName, ";");
                    } else {
                        if (attrib.getMultiplicity().isOrdered()) {
                            writeln(
                                "return java.util.Collections.unmodifiableList(", 
                                fieldName,
                                ");");
                        } else {
                            writeln(
                                "return java.util.Collections.unmodifiableSet(",
                                fieldName,
                                ");");                            
                        }
                    }
                    endBlock();
                }
            }
            
            // reference methods
            for(Reference ref: instanceReferences) {
                newLine();

                AssociationInfo assocInfo = refInfo.get(ref);
                if (assocInfo == null) {
                    throw new GenerationException(
                        "unknown reference '" + ref.getName() + "'");
                }
                switch(assocInfo.kind) {
                case ONE_TO_ONE:
                    {
                        startAccessorBlock(ref);
                        startConditionalBlock(
                            CondType.IF,
                            assocInfo.accessorName,
                            "() == null");
                        writeln("return null;");
                        endBlock();

                        writeln(
                            "return ", 
                            assocInfo.accessorName,
                            "().get", assocInfo.getEndName(ref, true), "(",
                            assocInfo.getEndType(ref, true),
                            ".class",
                            ");");
                        endBlock();
                        
                        if (ref.isChangeable()) {
                            newLine();
                            startMutatorBlock(ref);
                            
                            // Get existing association if any.
                            writeln(
                                ASSOCIATION_BASE_CLASS,
                                " assoc = getAssociation(",
                                QUOTE, assocInfo.baseName, QUOTE, ");");
                            startConditionalBlock(
                                CondType.IF, 
                                "assoc == null && newValue != null");
                            // If non exists, get the new value's association.
                            writeln(
                                "assoc = ((", 
                                ASSOCIABLE_INTERFACE, 
                                ")newValue).getAssociation(",
                                QUOTE, assocInfo.baseName, QUOTE, ");");
                            endBlock();

                            startConditionalBlock(
                                CondType.IF, "assoc == null");
                            // Create an association if we haven't found one.
                            writeln(
                                "assoc = getOrCreateAssociation(",
                                QUOTE, assocInfo.baseName, QUOTE,
                                ");");
                            endBlock();

                            if (assocInfo.getEndIndex(ref, false) == 0) {
                                writeln(
                                    "assoc.add(this, (", 
                                    ASSOCIABLE_INTERFACE,
                                    ")newValue);");
                            } else {
                                writeln(
                                    "assoc.add((", 
                                    ASSOCIABLE_INTERFACE,
                                    ")newValue, this);");
                            }
                            endBlock();                        
                        }
                        break;
                    }
                
                case ONE_TO_MANY: 
                    {
                        startAccessorBlock(ref);
                        boolean hasParent = 
                            ref.getMultiplicity().getUpper() == 1;
                        if (hasParent) {
                            startConditionalBlock(
                                CondType.IF, 
                                assocInfo.accessorName,
                                "() == null");
                            writeln("return null;");
                            endBlock();
                            writeln(
                                "return (",
                                assocInfo.types[assocInfo.isSingle(0) ? 0 : 1],                            
                                ")", 
                                assocInfo.accessorName, 
                                "().getParent();");
                        } else {
                            String listElemType = 
                                assocInfo.types[assocInfo.isSingle(0) ? 1 : 0];
                            // TODO: Cache ListProxy in a field?
                            startConditionalBlock(
                                CondType.IF, 
                                assocInfo.accessorName,
                                "() == null");
                            writeln(
                                "return new ", 
                                LIST_PROXY_CLASS,
                                "<", listElemType, ">",
                                "(", QUOTE, assocInfo.baseName, QUOTE,
                                ", this, ",
                                listElemType, ".class);");
                            startConditionalBlock(CondType.ELSE);
                            writeln(
                                "return new ",
                                LIST_PROXY_CLASS,
                                "<", listElemType, ">",
                                "(",
                                assocInfo.accessorName,
                                "(), this, ",
                                listElemType, ".class);");
                            endBlock();
                        }
                        endBlock();
                        
                        if (hasParent && ref.isChangeable()) {
                            newLine();
                            startMutatorBlock(ref);
                            writeln(
                                ASSOCIATION_BASE_CLASS,
                                " assoc = getAssociation(",
                                QUOTE, assocInfo.baseName, QUOTE, ");");
                            startConditionalBlock(
                                CondType.IF, 
                                "assoc == null && newValue != null");
                            // If non exists, get the new value's association.
                            writeln(
                                "assoc = ((", 
                                ASSOCIABLE_INTERFACE, 
                                ")newValue).getAssociation(",
                                QUOTE, assocInfo.baseName, QUOTE, ");");
                            endBlock();

                            startConditionalBlock(
                                CondType.IF, "assoc == null");
                            // Create an association if we haven't found one.
                            writeln(
                                "assoc = getOrCreateAssociation(",
                                QUOTE, assocInfo.baseName, QUOTE,
                                ");");
                            endBlock();

                            // NOTE: we don't cast to the "$Impl" type here 
                            // because they do not inherit from each other
                            // and there may be multiple implementations of
                            // the parent interface.
                            writeln(
                                "assoc.add((",
                                ASSOCIABLE_INTERFACE,
                                ")newValue, this);");
                            endBlock();                        
                        }
                        break;
                    }
                
                case MANY_TO_MANY:
                    {
                        startAccessorBlock(ref);
                        String listElemType = assocInfo.getEndType(ref, true);
                        // TODO: Cache ListProxy in a field?
                        startConditionalBlock(
                            CondType.IF,
                            assocInfo.accessorName,
                            "() == null");
                        writeln(
                            "return new ", 
                            LIST_PROXY_CLASS,
                            "<", listElemType, ">",
                            "(", QUOTE, assocInfo.baseName, QUOTE,
                            ", this, ",
                            listElemType, ".class);");
                        startConditionalBlock(CondType.ELSE);
                        writeln(
                            "return new ",
                            LIST_PROXY_CLASS,
                            "<", listElemType, ">",
                            "(", 
                            assocInfo.accessorName, "(), this, ",
                            listElemType, ".class);");
                        endBlock();
                        endBlock();
                        break;
                    }
                }

                newLine();
                writeln("// Internal use only");
                startBlock(
                    "public ",
                    assocInfo.makeType(false),
                    " ",
                    assocInfo.accessorName,
                    "()");
                writeln("return ", assocInfo.fieldName, ";");
                endBlock();

                newLine();
                writeln("// Internal use only");
                startBlock(
                    "public void ",
                    assocInfo.mutatorName,
                    "(",
                    assocInfo.makeType(false),
                    " newValue)");
                writeln("this.", assocInfo.fieldName, " = newValue;");
                endBlock();
            }

            // TODO: Emit private static final fields for the assoc base names.
            
            // Implement HibernateAssociable
            if (!instanceReferences.isEmpty()) {
                newLine();
                writeln("// Implement HibernateAssociable");
                startBlock(
                    "public ",
                    ASSOCIATION_BASE_CLASS,
                    " getAssociation(String type)");
                boolean first = true;
                for(Reference ref: instanceReferences) {
                    AssociationInfo assocInfo = refInfo.get(ref);
                    
                    startConditionalBlock(
                        first ? CondType.IF : CondType.ELSEIF,
                        QUOTE,
                        assocInfo.baseName,
                        QUOTE,
                        ".equals(type)");
                    writeln(
                        "return ", assocInfo.accessorName, "();");
                    first = false;
                }
                startConditionalBlock(CondType.ELSE);
                writeln(
                    "throw new IllegalArgumentException(",
                    QUOTE, "Unknown assoc type '", QUOTE,
                    " + type + ", QUOTE, "'", QUOTE, ");");
                endBlock();
                endBlock();

                newLine();
                writeln("// Implement HibernateAssociable");
                startBlock(
                    "public void setAssociation(String type, ",
                    ASSOCIATION_BASE_CLASS, " assoc)");
                first = true;
                for(Reference ref: instanceReferences) {
                    AssociationInfo assocInfo = refInfo.get(ref);
                    
                    startConditionalBlock(
                        first ? CondType.IF : CondType.ELSEIF,
                        QUOTE,
                        assocInfo.baseName,
                        QUOTE,
                        ".equals(type)");
                    writeln(
                        assocInfo.mutatorName,
                        "((",
                        assocInfo.makeType(false),
                        ")assoc);");
                    first = false;
                }
                startConditionalBlock(CondType.ELSE);
                writeln(
                    "throw new IllegalArgumentException(",
                    QUOTE, "Unknown assoc type '", QUOTE,
                    " + type + ", QUOTE, "'", QUOTE, ");");
                endBlock();
                endBlock();

                newLine();
                writeln("// Implement HibernateAssociable");
                startBlock(
                    "public ",
                    ASSOCIATION_BASE_CLASS,
                    " getOrCreateAssociation(String type)");
                first = true;
                for(Reference ref: instanceReferences) {
                    AssociationInfo assocInfo = refInfo.get(ref);
                    startConditionalBlock(
                        first ? CondType.IF : CondType.ELSEIF,
                        QUOTE,
                        assocInfo.baseName,
                        QUOTE,
                        ".equals(type)");
                    startConditionalBlock(
                        CondType.IF, assocInfo.accessorName, "() == null");
                        
                    writeln(
                        assocInfo.makeType(false),
                        " assoc = new ",
                        assocInfo.makeType(false),
                        "();");
                    writeln("assoc.setType(type);");
                    
                    // Set up the local end of the association.
                    switch(assocInfo.kind) {
                    case ONE_TO_ONE:
                        writeln(
                            "assoc.set",
                            assocInfo.getEndName(ref, false),
                            "(this);");
                        break;
                        
                    case MANY_TO_MANY:
                        writeln("assoc.setSource(this);");
                        break;
                        
                    case ONE_TO_MANY:
                        boolean hasParent = 
                            ref.getMultiplicity().getUpper() == 1;
                        if (!hasParent) {
                            writeln("assoc.setParent(this);");
                        } else {
                            writeln("assoc.getChildren().add(this);");
                        }
                        break;
                    }
                    
                    writeln(assocInfo.mutatorName, "(assoc);");
                    endBlock();
                    writeln("return ", assocInfo.accessorName, "();");
                    first = false;
                }
                startConditionalBlock(CondType.ELSE);
                writeln(
                    "throw new IllegalArgumentException(",
                    QUOTE, "Unknown assoc type '", QUOTE,
                    " + type + ", QUOTE, "'", QUOTE, ");");
                endBlock();
                endBlock();
            }

            writeEntityFooter();
        }
        finally {
            close();
        }
    }

    public void generateClassProxy(MofClass cls)
        throws GenerationException
    {
        String interfaceName = generator.getTypeName(cls, CLASS_PROXY_SUFFIX);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        String instImplTypeName = generator.getTypeName(cls, IMPL_SUFFIX);
        
        log.fine("Generating Class Proxy Implementation '" + typeName + "'");

        open(typeName);
        try {
            writeClassHeader(
                cls,
                typeName, 
                REF_CLASS_IMPL_CLASS.toString(),
                new String[] { interfaceName }, 
                false,
                CLASS_PROXY_IMPL_COMMENT);
            
            if (!cls.isAbstract()) {
                // No-arg factory method
                startCreatorBlock(cls, null, "");
                writeln("return new ", instImplTypeName, "();");
                endBlock();
                
                Collection<Attribute> allAttributes =
                    contentsOfType(
                        cls, 
                        HierachySearchKindEnum.INCLUDE_SUPERTYPES, 
                        ScopeKindEnum.INSTANCE_LEVEL,
                        Attribute.class);
                for(Iterator<Attribute> i = allAttributes.iterator(); 
                    i.hasNext(); ) 
                {
                    Attribute attrib = i.next();
                    
                    if (attrib.isDerived()) {
                        i.remove();
                    }
                }
                
                // factory method                
                if (allAttributes.size() > 0) {
                    newLine();
                    
                    ModelElement[] params = 
                        allAttributes.toArray(
                            new ModelElement[allAttributes.size()]);
                    startCreatorBlock(cls, params, "");                    
                    writeln(
                        "return new ",
                        instImplTypeName,
                        "(");
                    increaseIndent();
                    for(Iterator<Attribute> i = allAttributes.iterator(); 
                        i.hasNext(); ) 
                    {
                        Attribute attrib = i.next();
                        
                        String[] paramInfo = generator.getParam(attrib);

                        writeln(paramInfo[1], i.hasNext() ? "," : ");");
                    }
                    decreaseIndent();
                    endBlock();
                }
            }

            writeEntityFooter();
        }
        finally {
            close();
        }
    }

    public void generatePackage(MofPackage pkg)
        throws GenerationException
    {
        String interfaceName = 
            generator.getTypeName(pkg, PACKAGE_SUFFIX);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        log.fine("Generating Package Implementation '" + typeName + "'");

        open(typeName);
        try {
            writeClassHeader(
                pkg,
                typeName, 
                REF_PACKAGE_IMPL_CLASS.toString(),
                new String[] { interfaceName }, 
                false,
                PACKAGE_IMPL_COMMENT);
            
            // Generate fields for all nested packages, class proxies and
            // associations.
            
            ArrayList<String> packageFieldNames = new ArrayList<String>();
            Collection<MofPackage> packages =
                contentsOfType(pkg, MofPackage.class);
            boolean hasPackages = !packages.isEmpty();
            if (hasPackages) {
                writeln("// Packages");
            }
            for(MofPackage nestedPkg: packages) {
                String fieldName = 
                    writePrivateField(
                        nestedPkg, true, false, PACKAGE_SUFFIX);
                packageFieldNames.add(fieldName);
            }
            
            ArrayList<String> classFieldNames = new ArrayList<String>();
            Collection<MofClass> classes = contentsOfType(pkg, MofClass.class);
            boolean hasClasses = !classes.isEmpty();
            if (hasClasses) {
                if (hasPackages) {
                    newLine();
                }
                writeln("// Class Proxies");
            }
            for(MofClass cls: classes) {
                String fieldName =
                    writePrivateField(
                        cls, true, false, CLASS_PROXY_SUFFIX);
                classFieldNames.add(fieldName);
            }
            
            ArrayList<String> assocFieldNames = new ArrayList<String>();
            Collection<Association> assocs = 
                contentsOfType(pkg, Association.class);
            boolean hasAssocs = !assocs.isEmpty();
            if (hasAssocs) {
                if (hasPackages || hasClasses) {
                    newLine();
                }
                writeln("// Associations");
            }
            for(Association assoc: assocs) {
                String fieldName =
                    writePrivateField(assoc, true, false, "");
                assocFieldNames.add(fieldName);
            }
            newLine();
            
            // constructor (initializes fields)       
            startBlock(
                "public ",
                generator.getSimpleTypeName(pkg, PACKAGE_SUFFIX + IMPL_SUFFIX),
                "()");

            // initialize nested package fields
            Iterator<String> nameIter;
            Iterator<MofPackage> pkgIter;
            for(
                nameIter = packageFieldNames.iterator(),
                    pkgIter = packages.iterator();
                nameIter.hasNext() && pkgIter.hasNext(); )
            {
                writeln(
                    "this.",
                    nameIter.next(),
                    " = new ",
                    generator.getTypeName(
                        pkgIter.next(), PACKAGE_SUFFIX + IMPL_SUFFIX),
                    "();");
            }
            
            // initialize class proxy fields 
            if (hasClasses && hasPackages) {
                newLine();
            }
            
            Iterator<MofClass> clsIter;
            for(
                nameIter = classFieldNames.iterator(),
                    clsIter = classes.iterator();
                nameIter.hasNext() && clsIter.hasNext(); )
            {
                writeln(
                    "this.",
                    nameIter.next(),
                    " = new ",
                    generator.getTypeName(
                        clsIter.next(), CLASS_PROXY_SUFFIX + IMPL_SUFFIX),
                    "();");
            }

            // initialize association fields
            if (hasAssocs && 
                (hasPackages || hasClasses))
            {
                newLine();
            }
            
            Iterator<Association> assocIter;
            for(
                nameIter = assocFieldNames.iterator(),
                    assocIter = assocs.iterator();
                nameIter.hasNext() && assocIter.hasNext(); )
            {
                writeln(
                    "this.",
                    nameIter.next(),
                    " = new ",
                    generator.getTypeName(assocIter.next(), IMPL_SUFFIX),
                    "();");
            }
            
            endBlock();
            newLine();
            
            // generate accessor methods

            if (hasPackages) {
                writeln("// Package Accessors");
                newLine();
            }

            // package accessors
            for(
                nameIter = packageFieldNames.iterator(),
                    pkgIter = packages.iterator();
                nameIter.hasNext() && pkgIter.hasNext(); )
            {
                MofPackage nestedPkg = pkgIter.next();
                startPackageAccessorBlock(nestedPkg, PACKAGE_SUFFIX);
                
                writeln("return ", nameIter.next(), ";");                

                endBlock();
                newLine();
            }
            
            // class proxy accessors
            if (hasClasses) {
                if (hasPackages) {
                    newLine();
                }
                writeln("// Class Proxy Accessors");
                newLine();
            }
            
            for(
                nameIter = classFieldNames.iterator(),
                    clsIter = classes.iterator();
                nameIter.hasNext() && clsIter.hasNext(); )
            {
                MofClass cls = clsIter.next();
                startPackageAccessorBlock(cls, CLASS_PROXY_SUFFIX);
                
                writeln("return ", nameIter.next(), ";");
                
                endBlock();
                newLine();
            }

            // association accessors
            if (hasAssocs) {
                if (hasPackages || hasClasses) {
                    newLine();
                }
                writeln("// Association Accessors");
                newLine();
            }
            for(
                nameIter = assocFieldNames.iterator(),
                    assocIter = assocs.iterator();
                nameIter.hasNext() && assocIter.hasNext(); )
            {
                Association assoc = assocIter.next();
                startPackageAccessorBlock(assoc, "");
                
                writeln("return ", nameIter.next(), ";");
                
                endBlock();
                newLine();
            }
            
            writeEntityFooter();
        }
        finally {
            close();
        }
    }
    
    private static class AssociationInfo
    {
        final Association assoc;
        final AssociationKindEnum kind;
        final AssociationEnd[] ends;
        final String[] types;
        final String[] names;
        
        final String baseName;
        final String fieldName;
        final String accessorName;
        final String mutatorName;
        
        private AssociationInfo(Generator generator, Association assoc)
        {
            this.assoc = assoc;
            this.kind = generator.getAssociationKind(assoc);
            
            Collection<?> contents = assoc.getContents();
            assert(contents.size() == 2) : "association must have 2 ends";
            
            Iterator<?> iter = contents.iterator();
            this.ends = new AssociationEnd[] {
                (AssociationEnd)iter.next(),
                (AssociationEnd)iter.next()
            };            

            this.names = new String[] {
                generator.getSimpleTypeName(ends[0]),
                generator.getSimpleTypeName(ends[1]),
            };
            
            this.types = new String[] {
                generator.getTypeName(ends[0].getType()),
                generator.getTypeName(ends[1].getType()),
            };
            
            this.baseName = generator.getSimpleTypeName(assoc);
            String baseImplName = baseName + IMPL_SUFFIX;
            this.fieldName = toInitialLower(baseImplName);
            this.accessorName = "get" + baseImplName;
            this.mutatorName = "set" + baseImplName;
        }
        
        public boolean isSingle(int end)
        {
            return ends[end].getMultiplicity().getUpper() == 1;
        }
        
        public boolean isOrdered(int end)
        {
            return ends[end].getMultiplicity().isOrdered();
        }
        
        public boolean isChangeable(int end)
        {
            return ends[end].isChangeable();
        }
        
        public int getEndIndex(Reference ref, boolean refEnd)
        {
            AssociationEnd end = 
                refEnd ? ref.getReferencedEnd() : ref.getExposedEnd();
            
            for(int i = 0; i < ends.length; i++) {
                if (ends[i] == end) {
                    return i;
                }
            }
            
            return -1;
        }
        
        public String getEndName(Reference ref, boolean refEnd)
        {
            int index = getEndIndex(ref, refEnd);
            assert(index >= 0 && index <= 1);

            switch(kind) {
            case ONE_TO_ONE:
                return index == 0 ? "Left" : "Right";
                
            case ONE_TO_MANY:
                return index == 0 ? "Parent" : "Children";
                
            default:
            case MANY_TO_MANY:
                return "Target";
            }
        }
        
        public String getEndType(Reference ref, boolean refEnd)
        {
            int index = getEndIndex(ref, refEnd);
            assert(index >= 0 && index <= 1);

            return types[index];
        }
        
        public String makeType(boolean isRefAssoc)
        {
            StringBuffer type = new StringBuffer();
            if (isSingle(0) && isSingle(1)) {
                if (isRefAssoc) {
                    type.append(REF_ASSOCIATION_ONE_TO_ONE_IMPL_CLASS);
                    type
                    .append("<")
                    .append(types[0])
                    .append(", ")
                    .append(types[1])
                    .append(">");
                } else {
                    type.append(ASSOCIATION_ONE_TO_ONE_IMPL_CLASS);
                }
            } else if (!isSingle(0) && !isSingle(1)) {
                if (isRefAssoc) {
                    type.append(REF_ASSOCIATION_MANY_TO_MANY_IMPL_CLASS);
                    type
                        .append("<")
                        .append(types[0])
                        .append(", ")
                        .append(types[1])
                        .append(">");
                } else {
                    type.append(ASSOCIATION_MANY_TO_MANY_IMPL_CLASS);
                }
            } else {
                if (isRefAssoc) {
                    type.append(REF_ASSOCIATION_ONE_TO_MANY_IMPL_CLASS);
                    type
                        .append("<")    
                        .append(isSingle(0) ? types[0] : types[1])
                        .append(", ")
                        .append(isSingle(0) ? types[1] : types[0])
                        .append(">");
                } else {
                    type.append(ASSOCIATION_ONE_TO_MANY_IMPL_CLASS);
                }
            }

            return type.toString();
        }
    }
}

/*
// $Id$
// Enki generates and implements the JMI and MDR APIs for MOF metamodels.
// Copyright (C) 2007-2007 The Eigenbase Project
// Copyright (C) 2007-2007 Disruptive Tech
// Copyright (C) 2007-2007 LucidEra, Inc.
//
// This library is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or (at
// your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/
package org.eigenbase.enki.hibernate.codegen;

import java.io.*;
import java.security.*;
import java.util.*;
import java.util.logging.*;

import javax.jmi.model.*;
import javax.jmi.reflect.*;

import org.eigenbase.enki.codegen.*;
import org.eigenbase.enki.hibernate.jmi.*;
import org.eigenbase.enki.hibernate.storage.*;
import org.eigenbase.enki.jmi.impl.*;
import org.eigenbase.enki.mdr.*;
import org.eigenbase.enki.util.*;

/**
 * HibernateJavaHandler generates Java implementations for the JMI/MOF
 * interfaces generated by the {@link JmiTemplateHandler default code 
 * generation}.
 *  
 * @author Stephan Zuercher
 */
public class HibernateJavaHandler
    extends JavaHandlerBase
    implements 
        AssociationHandler, 
        ClassInstanceHandler, 
        ClassProxyHandler,
        PackageHandler
{
    // REVIEW: SWZ: 11/7/2007: Relies on JmiTemplateHandler to throw
    // for cases (e.g., Import, StructureType) that we don't handle yet.    

    private static final String PROTECTED_SCOPE = "protected";

    private static final String PRIVATE_SCOPE = "private";

    /** 
     * Suffix for implementation class names and association implementation
     * methods.
     */
    public static final String IMPL_SUFFIX = "$Impl";

    /**
     * Name of the base class for classes that implement {@link RefObject}.
     */
    public static final JavaClassReference REF_OBJECT_IMPL_CLASS = 
        new JavaClassReference(HibernateRefObject.class);

    /**
     * Name of the base class for classes that implement {@link RefClass}.
     */
    public static final JavaClassReference REF_CLASS_IMPL_CLASS = 
        new JavaClassReference(HibernateRefClass.class);
    
    /**
     * Name of the base class for classes that implement {@link RefPackage}.
     */
    public static final JavaClassReference REF_PACKAGE_IMPL_CLASS = 
        new JavaClassReference(HibernateRefPackage.class);

    /**
     * Name of the provider-agnostic base class for classes that implement 
     * {@link RefPackage}.
     */
    public static final JavaClassReference REF_PACKAGE_BASE_CLASS = 
        new JavaClassReference(RefPackageBase.class);
    
    /**
     * Name of the base class for classes that implement {@link RefAssociation}
     * for one-to-many associations.
     */
    public static final JavaClassReference REF_ASSOCIATION_ONE_TO_MANY_IMPL_CLASS = 
        new JavaClassReference(HibernateOneToManyRefAssociation.class);

    /**
     * Name of the base class for classes that implement {@link RefAssociation}
     * for one-to-one associations.
     */
    public static final JavaClassReference REF_ASSOCIATION_ONE_TO_ONE_IMPL_CLASS =
        new JavaClassReference(HibernateOneToOneRefAssociation.class);
    
    /**
     * Name of the base class for classes that implement {@link RefAssociation}
     * for many-to-many associations.
     */
    public static final JavaClassReference REF_ASSOCIATION_MANY_TO_MANY_IMPL_CLASS =
        new JavaClassReference(HibernateManyToManyRefAssociation.class);
    
    /**
     * Name of the base class for stored objects.
     */
    public static final JavaClassReference OBJECT_IMPL_CLASS = 
        new JavaClassReference(HibernateObject.class, true);
    
    /**
     * Name of the base class for stored objects that are participants in one 
     * or more types of Association.
     */
    public static final JavaClassReference ASSOCIABLE_INTERFACE = 
        new JavaClassReference(HibernateAssociable.class, true);

    /**
     * Name of the base class for all associations.
     */
    public static final JavaClassReference ASSOCIATION_INTERFACE = 
        new JavaClassReference(HibernateAssociation.class, true);
    
    /**
     * Name of the base class for one-to-one associations.
     */
    public static final JavaClassReference ASSOCIATION_ONE_TO_ONE_LAZY_BASE = 
        new JavaClassReference(HibernateOneToOneLazyAssociation.class, false);
    
    /**
     * Name of the base class for lazy one-to-many associations.
     */
    public static final JavaClassReference ASSOCIATION_ONE_TO_MANY_LAZY_BASE = 
        new JavaClassReference(HibernateOneToManyLazyAssociation.class, false);
    
    /**
     * Name of the base class for lazy, high cardinality one-to-many 
     * associations.
     */
    public static final JavaClassReference ASSOCIATION_ONE_TO_MANY_LAZY_HIGH_CARDINALITY_BASE = 
        new JavaClassReference(HibernateOneToManyLazyHighCardinalityAssociation.class, false);
    
    /**
     * Name of the base class for one-to-many associations.
     */
    public static final JavaClassReference ASSOCIATION_ONE_TO_MANY_LAZY_ORDERED_BASE = 
        new JavaClassReference(
            HibernateOneToManyLazyOrderedAssociation.class, false);
    
    /**
     * Name of the base class for many-to-many associations.
     */
    public static final JavaClassReference ASSOCIATION_MANY_TO_MANY_LAZY_BASE = 
        new JavaClassReference(HibernateManyToManyLazyAssociation.class, false);

    /**
     * Name of the base class for ordered many-to-many associations.
     */
    public static final JavaClassReference ASSOCIATION_MANY_TO_MANY_LAZY_ORDERED_BASE = 
        new JavaClassReference(
            HibernateManyToManyLazyOrderedAssociation.class, false);

    /**
     * Name of the class for lazy one associations elements.
     */
    public static final JavaClassReference ASSOCIATION_LAZY_ELEMENT = 
        new JavaClassReference(
            HibernateLazyAssociationBase.Element.class, false);
    
    /** Reference to {@link CollectionProxy}. */
    private static final JavaClassReference COLLECTION_PROXY_CLASS = 
        new JavaClassReference(CollectionProxy.class, true);
    
    /** Reference to {@link ListProxy}. */
    private static final JavaClassReference LIST_PROXY_CLASS = 
        new JavaClassReference(ListProxy.class, true);
    
    /** Reference to {@link AttributeCollectionProxy}. */
    private static final JavaClassReference ATTRIB_COLLECTION_PROXY_CLASS = 
        new JavaClassReference(AttributeCollectionProxy.class, true);
    
    /** Reference to {@link AttributeListProxy}. */
    private static final JavaClassReference ATTRIB_LIST_PROXY_CLASS = 
        new JavaClassReference(AttributeListProxy.class, true);
    
    /** Reference to {@link AttributeCollectionWrapper}. */
    private static final JavaClassReference ATTRIB_COLLECTION_WRAPPER_CLASS = 
        new JavaClassReference(AttributeCollectionWrapper.class, true);
    
    /** Reference to {@link AttributeListWrapper}. */
    private static final JavaClassReference ATTRIB_LIST_WRAPPER_CLASS = 
        new JavaClassReference(AttributeListWrapper.class, true);
    
    /** Class comment for {@link RefPackage} implementations. */
    private static final String PACKAGE_IMPL_COMMENT = 
        "{0} package implementation.";

    /** Class comment for {@link RefClass} implementations. */
    private static final String CLASS_PROXY_IMPL_COMMENT = 
        "{0} class proxy implementation.";

    /** Class comment for {@link RefAssociation} implementations. */
    private static final String ASSOC_IMPL_COMMENT = 
        "{0} association implementation.";

    /**
     * Name of the class used to stored unordered collections of attributes.
     */
    private static final JavaClassReference COLLECTION_IMPL_CLASS = 
        new JavaClassReference(HashSet.class);

    /**
     * Name of the class used to stored ordered collections of attributes.
     */
    private static final JavaClassReference ORDERED_COLLECTION_IMPL_CLASS = 
        new JavaClassReference(ArrayList.class);

    /** Reference to {@link List}. */
    private static final JavaClassReference JAVA_UTIL_LIST_CLASS =
        new JavaClassReference(List.class, true);
    
    /** Reference to {@link Collections}. */
    private static final JavaClassReference JAVA_UTIL_COLLECTIONS_CLASS =
        new JavaClassReference(Collections.class, true);
    
    /** Reference to {@link Collections}. */
    private static final JavaClassReference JAVA_UTIL_COLLECTION_CLASS =
        new JavaClassReference(Collection.class, true);
    
    /** Reference to {@link Arrays}. */
    private static final JavaClassReference JAVA_UTIL_ARRAYS_CLASS =
        new JavaClassReference(Arrays.class, true);
    
    /** Reference to {@link Arrays}. */
    private static final JavaClassReference JAVA_UTIL_ARRAYLIST_CLASS =
        new JavaClassReference(ArrayList.class, true);
    
    /** Reference to {@link GenericCollections}. */
    private static final JavaClassReference GENERIC_COLLECTIONS_CLASS =
        new JavaClassReference(GenericCollections.class, true);
    
    /** Reference to {@link UnsupportedOperationException}. */
    private static final JavaClassReference UNSUPPORTED_OPERATION_EXCEPTION =
        new JavaClassReference(UnsupportedOperationException.class, true);
    
    /** Reference to {@link MetamodelInitializer}. */
    private static final JavaClassReference METAMODEL_INITIALIZER_CLASS =
        new JavaClassReference(MetamodelInitializer.class, true);
    
    /** Reference to {@link CreateInstanceEvent}. */
    private static final JavaClassReference CREATE_INSTANCE_EVENT_CLASS =
        new JavaClassReference(CreateInstanceEvent.class, true);
    
    /** Reference to {@link HibernateConstraintChecker}. */
    private static final JavaClassReference CONSTRAINT_CHECKER_CLASS =
        new JavaClassReference(HibernateConstraintChecker.class, false);
    
    /** References to import into class instance implementations. */
    private static final JavaClassReference[] CLASS_INSTANCE_REFS = {
        OBJECT_IMPL_CLASS,
        ASSOCIABLE_INTERFACE,
        ASSOCIATION_INTERFACE,
        COLLECTION_PROXY_CLASS,
        LIST_PROXY_CLASS,
        ATTRIB_LIST_PROXY_CLASS,
        ATTRIB_COLLECTION_PROXY_CLASS,
        ATTRIB_LIST_WRAPPER_CLASS,
        ATTRIB_COLLECTION_WRAPPER_CLASS,
        JAVA_UTIL_COLLECTION_CLASS,
        JAVA_UTIL_LIST_CLASS,
        JAVA_UTIL_ARRAYLIST_CLASS,
        JAVA_UTIL_COLLECTIONS_CLASS,
        GENERIC_COLLECTIONS_CLASS,
        UNSUPPORTED_OPERATION_EXCEPTION,
    };
    
    private static final int numPasses = 2;
    private int numTransientPasses;
    
    private final Logger log = 
        Logger.getLogger(HibernateJavaHandler.class.getName());

    /** 
     * Transient MDR implementation handler.  Implementation of transient
     * classes, packages and associations are delegated to this handler. 
     */
    private final TransientImplementationHandler transientHandler;
    
    /** Map of {@link MofClass} to unique class identifier. */
    private Map<MofClass, String> classIdentifierMap;

    /** Map of {@link Association} to unique association identifier. */
    private Map<Association, String> assocIdentifierMap;
    
    /** Map of {@link Association} to {@link AssociationInfo}. */
    private Map<Association, AssociationInfo> assocInfoMap;
    
    /** Maps a component type to a list of references to it. */
    private Map<Classifier, List<ComponentInfo>> componentAttribMap;

    private Map<AssociationEnd, Integer> assocEndOrderMap;
    
    /** 
     * Reference to the model-specific, generated subclass of 
     * {@link HibernateOneToOneLazyAssociation}.
     */
    private JavaClassReference assocOneToOneLazyClass;

    /** 
     * Reference to the model-specific, generated subclass of 
     * {@link HibernateOneToManyLazyAssociation}.
     */
    private JavaClassReference assocOneToManyLazyClass;

    /** 
     * Reference to the model-specific, generated subclass of 
     * {@link HibernateOneToManyLazyHighCardinalityAssociation} configured for
     * high fan-out associations.
     */
    private JavaClassReference assocOneToManyLazyHighCardinalityClass;

    /** 
     * Reference to the model-specific, generated subclass of 
     * {@link HibernateOneToManyLazyOrderedAssociation}.
     */    
    private JavaClassReference assocOneToManyLazyOrderedClass;

    /** 
     * Reference to the model-specific, generated subclass of 
     * {@link HibernateManyToManyLazyAssociation}.
     */
    private JavaClassReference assocManyToManyLazyClass;
    
    /** 
     * Reference to the model-specific, generated subclass of 
     * {@link HibernateManyToManyLazyOrderedAssociation}.
     */
    private JavaClassReference assocManyToManyLazyOrderedClass;
    
    /**
     * Map from each clustered package to the importing package
     * designated as its "primary".  This forms a spanning tree
     * over the import graph.
     */
    private final Map<MofPackage, MofPackage> clusteringMap;

    private String tablePrefix;

    public HibernateJavaHandler()
    {
        super();

        this.transientHandler = new TransientImplementationHandler() {
            @Override
            protected String convertToTypeName(String entityName)
                throws GenerationException
            {
                return entityName + IMPL_SUFFIX;
            }
            
            @Override
            protected String computeSuffix(String baseSuffix)
            {
                if (baseSuffix != null) {
                    return baseSuffix + IMPL_SUFFIX;
                }
                return IMPL_SUFFIX;
            }
            
            @Override
            protected void generateCustomPackageInit(MofPackage pkg)
            {
                writeln(
                    METAMODEL_INITIALIZER_CLASS,
                    ".getCurrentInitializer().setRefMetaObject(this, ", 
                    QUOTE, pkg.getName(), QUOTE, ");");
            }
            
            @Override
            protected void generateCustomAssociationInit(Association assoc)
            {
                writeln(
                    METAMODEL_INITIALIZER_CLASS,
                    ".getCurrentInitializer().setRefMetaObject(this, ", 
                    QUOTE, assoc.getName(), QUOTE, ");");
            }

            @Override
            protected void generateCustomClassProxyInit(MofClass cls)
            {
                writeln(
                    METAMODEL_INITIALIZER_CLASS,
                    ".getCurrentInitializer().setRefMetaObject(this, ", 
                    QUOTE, cls.getName(), QUOTE, ");");
            }
        };
        
        this.classIdentifierMap = new HashMap<MofClass, String>();
        this.assocIdentifierMap = new HashMap<Association, String>();
        
        this.assocInfoMap = new LinkedHashMap<Association, AssociationInfo>();
        this.assocEndOrderMap = new HashMap<AssociationEnd, Integer>();
        this.componentAttribMap = 
            new HashMap<Classifier, List<ComponentInfo>>();
        this.clusteringMap = new HashMap<MofPackage, MofPackage>();
    }
    
    @Override
    public void setGenerator(Generator generator)
    {
        super.setGenerator(generator);
        
        transientHandler.setGenerator(generator);
    }

    public void setTablePrefix(String tablePrefix)
    {
        this.tablePrefix = tablePrefix;
    }

    @Override
    public void setOutputDir(File outputDir)
    {
        super.setOutputDir(outputDir);
        
        transientHandler.setOutputDir(outputDir);
    }

    @Override
    public int getNumPasses()
    {
        numTransientPasses = transientHandler.getNumPasses();
        
        return Math.max(numPasses, numTransientPasses);
    }
    
    @Override
    public void beginGeneration()
        throws GenerationException
    {
        super.beginGeneration();
        
        transientHandler.beginGeneration();
        
        ModelPackage modelPackage = 
            (ModelPackage)generator.getRefBaseObject();
        String packageName = 
            TagUtil.getFullyQualifiedPackageName(modelPackage);
        
        assocOneToOneLazyClass = 
            new JavaClassReference(
                packageName,
                ASSOCIATION_ONE_TO_ONE_LAZY_BASE.toSimple());
        assocOneToManyLazyClass = 
            new JavaClassReference(
                packageName,
                ASSOCIATION_ONE_TO_MANY_LAZY_BASE.toSimple());
        assocOneToManyLazyHighCardinalityClass = 
            new JavaClassReference(
                packageName,
                ASSOCIATION_ONE_TO_MANY_LAZY_HIGH_CARDINALITY_BASE.toSimple());
        assocOneToManyLazyOrderedClass = 
            new JavaClassReference(
                packageName,
                ASSOCIATION_ONE_TO_MANY_LAZY_ORDERED_BASE.toSimple());
        assocManyToManyLazyClass = 
            new JavaClassReference(
                packageName,
                ASSOCIATION_MANY_TO_MANY_LAZY_BASE.toSimple());
        assocManyToManyLazyOrderedClass = 
            new JavaClassReference(
                packageName,
                ASSOCIATION_MANY_TO_MANY_LAZY_ORDERED_BASE.toSimple());
    }

    @Override
    public void endGeneration(boolean throwing)
        throws GenerationException
    {
        if (!throwing && !pluginMode) {
            generateAssociationStorageSubclass(
                assocOneToOneLazyClass, 
                ASSOCIATION_ONE_TO_ONE_LAZY_BASE,
                AssociationKindEnum.ONE_TO_ONE,
                HibernateMappingHandler.ASSOC_ONE_TO_ONE_LAZY_TABLE,
                null);
            generateAssociationStorageSubclass(
                assocOneToManyLazyClass,
                ASSOCIATION_ONE_TO_MANY_LAZY_BASE,
                AssociationKindEnum.ONE_TO_MANY,
                HibernateMappingHandler.ASSOC_ONE_TO_MANY_LAZY_TABLE,
                HibernateMappingHandler.ASSOC_ONE_TO_MANY_LAZY_CHILDREN_TABLE);
            generateAssociationStorageSubclass(
                assocOneToManyLazyHighCardinalityClass,
                ASSOCIATION_ONE_TO_MANY_LAZY_HIGH_CARDINALITY_BASE,
                AssociationKindEnum.ONE_TO_MANY,
                HibernateMappingHandler.ASSOC_ONE_TO_MANY_LAZY_HC_TABLE,
                HibernateMappingHandler.ASSOC_ONE_TO_MANY_LAZY_HC_CHILDREN_TABLE);
            generateAssociationStorageSubclass(
                assocOneToManyLazyOrderedClass, 
                ASSOCIATION_ONE_TO_MANY_LAZY_ORDERED_BASE,
                AssociationKindEnum.ONE_TO_MANY,
                HibernateMappingHandler.ASSOC_ONE_TO_MANY_LAZY_ORDERED_TABLE,
                HibernateMappingHandler.ASSOC_ONE_TO_MANY_LAZY_ORDERED_CHILDREN_TABLE);
            generateAssociationStorageSubclass(
                assocManyToManyLazyClass, 
                ASSOCIATION_MANY_TO_MANY_LAZY_BASE,
                AssociationKindEnum.MANY_TO_MANY,
                HibernateMappingHandler.ASSOC_MANY_TO_MANY_LAZY_TABLE,
                HibernateMappingHandler.ASSOC_MANY_TO_MANY_LAZY_TARGET_TABLE);
            generateAssociationStorageSubclass(
                assocManyToManyLazyOrderedClass, 
                ASSOCIATION_MANY_TO_MANY_LAZY_ORDERED_BASE,
                AssociationKindEnum.MANY_TO_MANY,
                HibernateMappingHandler.ASSOC_MANY_TO_MANY_LAZY_ORDERED_TABLE,
                HibernateMappingHandler.ASSOC_MANY_TO_MANY_LAZY_ORDERED_TARGET_TABLE);
        }
        
        super.endGeneration(throwing);
        
        transientHandler.endGeneration(throwing);
    }
    
    /**
     * Generates a trivial, model-specific subclass with the given name.
     * 
     * @param classRef name of the subclass
     * @param superClassRef class to extend
     * @param assocKind the basic type of association
     * @param tableName association table name
     * @param collectionTableName association collection table name
     * @throws GenerationException if there is an error generating the class
     */
    private void generateAssociationStorageSubclass(
        JavaClassReference classRef, 
        JavaClassReference superClassRef,
        AssociationKindEnum assocKind,
        String tableName,
        String collectionTableName)
    throws GenerationException
    {
        String typeName = classRef.toFull();
        
        open(typeName);
        try {
            writeClassHeader(
                null, 
                typeName,
                superClassRef,
                new JavaClassReference[0],
                new JavaClassReference[] { ASSOCIATION_INTERFACE },
                false,
                "Model-specific storage sub-class.");
            
            if (tablePrefix != null) {
                tableName = tablePrefix + tableName;
            }
            writeConstant(
                "String", "_table", QUOTE + tableName + QUOTE, true);
            
            if (tablePrefix != null && collectionTableName != null) {
                collectionTableName = tablePrefix + collectionTableName;
            }
            if (collectionTableName != null) {
                writeConstant(
                    "String", "_collectionTable", 
                    QUOTE + collectionTableName + QUOTE, true);
            } else {
                writeConstant(
                    "String", "_collectionTable", "null", true);
            }
            newLine();
            
            startBlock("public ", classRef.toSimple(), "()");
            writeln("super();");
            endBlock();
            
            newLine();
            startBlock(
                "public Class<? extends ",
                ASSOCIATION_INTERFACE, 
                "> getInstanceClass()");
            writeln("return ", typeName, ".class;");
            endBlock();
                        
            newLine();
            startBlock("public String getTable()");
            writeln("return _table;");
            endBlock();
            
            newLine();
            startBlock("public String getCollectionTable()");
            writeln("return _collectionTable;");
            endBlock();
            
            writeEntityFooter();
        }
        finally {
            close();
        }
    }

    public void generateAssociation(Association assoc)
        throws GenerationException
    {
        if (!isIncluded(assoc)) {
            log.fine(
                "Skipping Excluded Association '" + assoc.getName() + "'");
            
            if (getPassIndex() == 0) {
                AssociationInfo assocInfo = new AssociationInfoImpl(assoc);
                assocInfoMap.put(assoc, assocInfo);
            }
            return;
        }
        
        if (CodeGenUtils.isTransient(assoc)) {
            if (getPassIndex() < numTransientPasses) {
                log.fine("Delegating Transient Association Implementation");
                transientHandler.generateAssociation(assoc);
            }
            return;
        }

        if (getPassIndex() > 0) {
            return;
        }
        
        String interfaceName = CodeGenUtils.getTypeName(assoc);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        log.fine("Generating Association Implementation '" + typeName + "'");

        AssociationInfo assocInfo = new AssociationInfoImpl(assoc);
        assocInfoMap.put(assoc, assocInfo);
        
        open(typeName);
        try {
            String superClass = makeRefType(assocInfo);
            
            writeClassHeader(
                assoc,
                typeName, 
                superClass,
                new String[] { interfaceName }, 
                JavaClassReference.computeImports(
                    METAMODEL_INITIALIZER_CLASS,
                    ASSOCIATION_INTERFACE),
                false,
                ASSOC_IMPL_COMMENT);
        
            String assocIdentifier = getAssociationIdentifier(assoc);
            writeConstant(
                "String", "_id", QUOTE + assocIdentifier + QUOTE, true);
            newLine();
            
            JavaClassReference implClass;
            HibernateAssociation.Kind implKind;
            switch(assocInfo.getKind()) {
            default:
                assert(false);
            case ONE_TO_ONE:
                implClass = assocOneToOneLazyClass;
                implKind = HibernateAssociation.Kind.ONE_TO_ONE;
                break;
            case ONE_TO_MANY:
                boolean ordered = 
                    assocInfo.isOrdered(0) || assocInfo.isOrdered(1);
                if (ordered) {
                    implClass = assocOneToManyLazyOrderedClass;
                    implKind = HibernateAssociation.Kind.ONE_TO_MANY_ORDERED;
                } else if (isHighCardinalityAssociation(assocInfo)) {
                    implClass = assocOneToManyLazyHighCardinalityClass;
                    implKind = 
                        HibernateAssociation.Kind.ONE_TO_MANY_HIGH_CARDINALITY;
                } else {
                    implClass = assocOneToManyLazyClass;
                    implKind = HibernateAssociation.Kind.ONE_TO_MANY;
                }
                break;
            case MANY_TO_MANY:
                // Base many-to-many all-links queries on first end only
                if (assocInfo.isOrdered(0)) {
                    implClass = assocManyToManyLazyOrderedClass;
                    implKind = HibernateAssociation.Kind.MANY_TO_MANY_ORDERED;
                } else {
                    implClass = assocManyToManyLazyClass;
                    implKind = HibernateAssociation.Kind.MANY_TO_MANY;
                }
                break;
            }
            
            String allLinksQueryName =
                implClass.toFull() + "." + 
                HibernateMappingHandler.QUERY_NAME_ALLLINKS;
            writeConstant(
                "String", "_allLinksQueryName", 
                QUOTE + allLinksQueryName + QUOTE, true);
            newLine();
            
            startConstructorBlock(
                assoc, 
                new String[] { REF_PACKAGE_CLASS.toString() }, 
                new String[] { "container" },
                true,
                IMPL_SUFFIX);
            writeln(
                "super(container, ", 
                QUOTE, assocInfo.getBaseName(), QUOTE, ", ",
                QUOTE, assocInfo.getEndName(0), QUOTE, ", ",
                assocInfo.getEndType(0), ".class, ",
                Multiplicity.fromMultiplicityType(
                    assocInfo.getEnd(0).getMultiplicity())
                    .toInstantiationString(), ", ",
                QUOTE, assocInfo.getEndName(1), QUOTE, ", ",
                assocInfo.getEndType(1), ".class, ",
                Multiplicity.fromMultiplicityType(
                    assocInfo.getEnd(1).getMultiplicity())
                    .toInstantiationString(),
                ");");
            newLine();
            writeln(
                METAMODEL_INITIALIZER_CLASS,
                ".getCurrentInitializer().setRefMetaObject(this, ", 
                QUOTE, assoc.getName(), QUOTE, ");");

            endBlock();
            newLine();
            
            // exists
            startGenericMethodBlock(
                assoc,
                "boolean",
                "exists", 
                assocInfo.getEndTypes(),
                assocInfo.getEndIdentifiers());
            writeln(
                "return super.exists(", 
                assocInfo.getEndIdentifier(0), ", ",
                assocInfo.getEndIdentifier(1), ");");
            endBlock();
            newLine();
            
            // get end1 from end2
            if (assocInfo.getEnd(0).isNavigable()) {
                boolean ordered = assocInfo.isOrdered(0);
                String returnTypeName = 
                    assocInfo.isSingle(0)
                        ? assocInfo.getEndType(0)
                        : CodeGenUtils.getCollectionType(
                            ordered 
                                ? JmiTemplateHandler.ORDERED_COLLECTION_CLASS
                                : JmiTemplateHandler.COLLECTION_CLASS,
                            assocInfo.getEndType(0));
                startGenericMethodBlock(
                    assoc,
                    returnTypeName,
                    CodeGenUtils.getAccessorName(
                        generator, assocInfo.getEnd(0), null),
                    new String[] { assocInfo.getEndType(1) },
                    new String[] { assocInfo.getEndIdentifier(1) });
                switch(assocInfo.getKind()) {
                case ONE_TO_ONE:
                    writeln(
                        "return getParentOf(", 
                        assocInfo.getEndIdentifier(1), ");");
                    break;

                case ONE_TO_MANY:
                    if (assocInfo.isSingle(0)) {
                        writeln(
                            "return getParentOf(", 
                            assocInfo.getEndIdentifier(1), ", ",
                            assocInfo.getEndType(0), ".class);");
                    } else if (assocInfo.isOrdered(0)) {
                        writeln(
                            "return (",
                            returnTypeName,
                            ")getChildrenOf(",
                            assocInfo.getEndIdentifier(1), ", ",
                            assocInfo.getEndType(0), ".class);");
                    } else {
                        writeln(
                            "return getChildrenOf(",
                            assocInfo.getEndIdentifier(1), ", ",
                            assocInfo.getEndType(0), ".class);");
                    }
                    break;
                    
                case MANY_TO_MANY:
                    if (assocInfo.isOrdered(0)) {
                        writeln(
                            "return (",
                            returnTypeName,
                            ")getSourceOf(", 
                            assocInfo.getEndIdentifier(1), ");");                        
                    } else {
                        writeln(
                            "return getSourceOf(", 
                            assocInfo.getEndIdentifier(1), ");");
                    }
                }
                endBlock();
                newLine();
            }
            
            // get end2 from end1
            if (assocInfo.getEnd(1).isNavigable()) {
                boolean ordered = assocInfo.isOrdered(1);
                String returnTypeName = 
                    assocInfo.isSingle(1) 
                        ? assocInfo.getEndType(1)
                        : CodeGenUtils.getCollectionType(
                            ordered 
                                ? JmiTemplateHandler.ORDERED_COLLECTION_CLASS
                                : JmiTemplateHandler.COLLECTION_CLASS,
                            assocInfo.getEndType(1));
                startGenericMethodBlock(
                    assoc,
                    returnTypeName,
                    CodeGenUtils.getAccessorName(generator, assocInfo.getEnd(1), null),
                    new String[] { assocInfo.getEndType(0) },
                    new String[] { assocInfo.getEndIdentifier(0) });
                switch(assocInfo.getKind()) {
                case ONE_TO_ONE:
                    writeln(
                        "return getChildOf(", 
                        assocInfo.getEndIdentifier(0), ");");
                    break;

                case ONE_TO_MANY:
                    if (assocInfo.isSingle(1)) {
                        writeln(
                            "return getParentOf(", 
                            assocInfo.getEndIdentifier(0), ", ",
                            assocInfo.getEndType(1), ".class);");
                    } else if (assocInfo.isOrdered(1)) {
                        writeln(
                            "return (",
                            returnTypeName,
                            ")getChildrenOf(", 
                            assocInfo.getEndIdentifier(0), ", ",
                            assocInfo.getEndType(1), ".class);");
                    } else {
                        writeln(
                            "return getChildrenOf(", 
                            assocInfo.getEndIdentifier(0), ", ",
                            assocInfo.getEndType(1), ".class);");
                    }
                    break;
                    
                case MANY_TO_MANY:
                    if (assocInfo.isOrdered(1)) {
                        writeln(
                            "return (",
                            returnTypeName,
                            ")getTargetOf(", 
                            assocInfo.getEndIdentifier(0), ");");
                    } else {
                        writeln(
                            "return getTargetOf(",
                            assocInfo.getEndIdentifier(0), ");");
                    }
                }
                endBlock();
                newLine();
            }

            if (assocInfo.isChangeable(0) && assocInfo.isChangeable(1)) {
                // add
                startGenericMethodBlock(
                    assoc,
                    "boolean",
                    "add",
                    assocInfo.getEndTypes(),
                    assocInfo.getEndIdentifiers());
                writeln(
                    "return super.add(",
                    assocInfo.getEndIdentifier(0),
                    ", ",
                    assocInfo.getEndIdentifier(1),
                    ");");
                endBlock();

                newLine();
                
                // remove
                startGenericMethodBlock(
                    assoc,
                    "boolean",
                    "remove",
                    assocInfo.getEndTypes(),
                    assocInfo.getEndIdentifiers());
                writeln(
                    "return super.remove(",
                    assocInfo.getEndIdentifier(0),
                    ", ",
                    assocInfo.getEndIdentifier(1),
                    ");");
                endBlock();
            }
            
            newLine();
            startBlock("protected String getAssociationIdentifier()");
            writeln("return _id;");
            endBlock();

            newLine();
            startBlock(
                "public Class<? extends ", 
                ASSOCIATION_INTERFACE, "> getInstanceClass()");
            writeln("return ", implClass.toFull(), ".class;");
            endBlock();
            
            newLine();
            startBlock("public ", ASSOCIATION_INTERFACE, ".Kind getKind()");
            writeln("return ", ASSOCIATION_INTERFACE, ".Kind.", implKind, ";");
            endBlock();
            
            newLine();
            startBlock("protected String getAllLinksQueryName()");
            writeln("return _allLinksQueryName;");
            endBlock();
            
            writeEntityFooter();
        }
        finally {
            close();
        }            
    }

    public void generateClassInstance(MofClass cls)
        throws GenerationException
    {
        if (!isIncluded(cls)) {
            log.fine(
                "Skipping Excluded Class Instance '" + cls.getName() + "'");
            return;
        }

        if (CodeGenUtils.isTransient(cls)) {
            if (getPassIndex() < numTransientPasses) {
                log.fine("Delegating Transient Class Instance Implementation");
                transientHandler.generateClassInstance(cls);
            }
            return;
        }

        // Build attribute information, ignoring super type attributes for
        // the first pass.
        HierachySearchKindEnum includeSupertypes = 
            getPassIndex() == 0
            ? HierachySearchKindEnum.ENTITY_ONLY
            : HierachySearchKindEnum.INCLUDE_SUPERTYPES;
        Collection<Attribute> instanceAttributes =
            CodeGenUtils.contentsOfType(
                cls,
                includeSupertypes, 
                VisibilityKindEnum.PUBLIC_VIS,
                ScopeKindEnum.INSTANCE_LEVEL,
                Attribute.class);
        ArrayList<Attribute> nonDerivedAttribs = 
            new ArrayList<Attribute>();
        Set<Attribute> nonDataTypeAttribs = new HashSet<Attribute>();
        for(Attribute attrib: instanceAttributes) {
            if (attrib.isDerived()) {
                continue;
            }
            
            nonDerivedAttribs.add(attrib);

            boolean isDataType = attrib.getType() instanceof DataType;
            
            if (!isDataType) {
                nonDataTypeAttribs.add(attrib);
            }
        }

        if (getPassIndex() == 0 && !cls.isAbstract()) {
            for(Attribute attrib: nonDataTypeAttribs) {
                addComponentAttrib(
                    attrib.getType(), 
                    new ComponentInfo(cls, attrib, false));
            }
        }
        
        if (checkPassIndex(1)) {
            return;
        }
        
        String interfaceName = CodeGenUtils.getTypeName(cls);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        if (cls.isAbstract()) {
            log.fine(
                "Skipping Class Instance Implementation '" + typeName + "'");
            return;
        }
        
        log.fine(
            "Generating Class Instance Implementation '" + typeName + "'");

        Collection<Reference> instanceReferences =
            CodeGenUtils.contentsOfType(
                cls,
                includeSupertypes, 
                VisibilityKindEnum.PUBLIC_VIS,
                Reference.class);

        Map<Reference, ReferenceInfo> refInfoMap = 
            buildRefInfoMap(instanceReferences);
        
        Map<Association, ReferenceInfo> unrefAssocRefInfoMap =
            new HashMap<Association, ReferenceInfo>();

        Collection<Association> unreferencedAssociations = 
            CodeGenUtils.findUnreferencedAssociations(
                assocInfoMap,
                cls,
                instanceReferences, 
                unrefAssocRefInfoMap);
        
        Map<Attribute, ComponentInfo> componentInfoMap = buildComponentInfoMap(
            cls,
            nonDataTypeAttribs);

        boolean hasAssociations = 
            !instanceReferences.isEmpty() || 
            !unreferencedAssociations.isEmpty() ||
            !componentInfoMap.isEmpty();
        
        open(typeName);
        try {            
            String[] interfaces;
            if (hasAssociations) {
                interfaces = new String[] { 
                    interfaceName, ASSOCIABLE_INTERFACE.toString()
                };
            } else {
                interfaces = new String[] { interfaceName };
            }
            
            writeClassHeader(
                cls, 
                typeName,
                REF_OBJECT_IMPL_CLASS.toString(),
                interfaces,
                JavaClassReference.computeImports(CLASS_INSTANCE_REFS),
                false,
                CLASS_COMMENT);
            
            String classIdentifier = getClassIdentifier(cls);
            writeConstant(
                "String", "_id", "\"" + classIdentifier + "\"", true);
            newLine();
            
            // fields
            writeln("// Attribute Fields");
            Map<Attribute, String> nonDerivedAttribNames = 
                new HashMap<Attribute, String>();
            for(Attribute attrib: nonDerivedAttribs) {
                if (!nonDataTypeAttribs.contains(attrib)) {
                    String fieldName = 
                        writeField(
                            attrib,
                            IMPL_SUFFIX,
                            PROTECTED_SCOPE, 
                            false, 
                            false,
                            true);
                    nonDerivedAttribNames.put(attrib, fieldName);
                }
            }
            newLine();
            
            if (!instanceReferences.isEmpty()) {
                // reference fields
                writeln("// Reference Fields");
                for(Reference ref: instanceReferences) {
                    ReferenceInfo refInfo = refInfoMap.get(ref);
                    
                    writeField(
                        makeType(refInfo),
                        generator.transformIdentifier(refInfo.getFieldName())
                            + IMPL_SUFFIX, 
                        PROTECTED_SCOPE, 
                        false,
                        false);
                }
                newLine();
            }
            
            if (!unreferencedAssociations.isEmpty()) {
                // REVIEW: SWZ: doesn't handle self-referential un-referenced 
                // associations (assuming such a thing is even valid)
                
                // unreferenced association fields
                writeln("// Unreferenced Association Fields");
                for(Association unref: unreferencedAssociations) {
                    ReferenceInfo refInfo = unrefAssocRefInfoMap.get(unref);
                    
                    writeField(
                        makeType(refInfo),
                        generator.transformIdentifier(refInfo.getFieldName())
                            + IMPL_SUFFIX,
                        PROTECTED_SCOPE,
                        false,
                        false);
                }
                newLine();
            }
            
            if (!componentInfoMap.isEmpty()) {
                // Component attributes are treated as if they are
                // associations.
                writeln("// Component Attributes Fields");
                for(ComponentInfo comonentInfo: componentInfoMap.values()) {
                    writeField(
                        makeType(comonentInfo),
                        comonentInfo.getFieldName() + IMPL_SUFFIX,
                        PROTECTED_SCOPE,
                        false,
                        false);
                }
                newLine();
            }
            
            // Constructors
            generateClassInstanceConstructors(
                cls,
                instanceAttributes,
                nonDerivedAttribs,
                nonDerivedAttribNames,
                nonDataTypeAttribs,
                componentInfoMap);
            
            // attribute methods
            generateClassInstanceAttribMethods(
                instanceAttributes,
                nonDerivedAttribNames,
                nonDataTypeAttribs);
            
            // reference methods
            generateClassInstanceRefMethods(instanceReferences, refInfoMap);

            // unreferenced association methods
            for(Association unrefAssoc: unreferencedAssociations) {
                ReferenceInfo refInfo = unrefAssocRefInfoMap.get(unrefAssoc);
                
                generateClassInstanceAssocMethods(refInfo);
            }

            generateClassInstanceComponentMethods(componentInfoMap, cls);
            
            // REVIEW: SWZ: Emit private static final fields for the 
            // association base names (and multi-valued attribute names)?
            
            // Implement HibernateAssociable
            if (hasAssociations) {
                List<ReferenceInfo> refInfos = 
                    gatherRefInfos(
                        instanceReferences, refInfoMap, 
                        unreferencedAssociations, unrefAssocRefInfoMap,
                        componentInfoMap);

                newLine();
                generateGetAssociationMethod(refInfos);

                newLine();
                generateSetAssociationMethod(refInfos);

                newLine();
                generateGetOrCreateAssociationMethod(refInfos);

                generateRemoveAssociationMethod(cls, refInfos);
                generateGetComposingAssociationsMethod(cls, refInfos);
                generateGetNonComposingAssociationsMethod(cls, refInfos);
            } else {
                generateRemoveAssociationMethod(cls, null);
                generateGetComposingAssociationsMethod(cls, null);
                generateGetNonComposingAssociationsMethod(cls, null);
            }

            generateRefImmediateComposite(
                cls, refInfoMap, unrefAssocRefInfoMap, componentInfoMap);
            
            newLine();
            generateClassInstanceCheckConstraints(
                instanceAttributes, instanceReferences, nonDataTypeAttribs);
            
            newLine();
            startBlock("public String getClassIdentifier()");
            writeln("return _id;");
            endBlock();
            
            writeEntityFooter();
        }
        finally {
            close();
        }
    }

    private Map<Attribute, ComponentInfo> buildComponentInfoMap(
        MofClass cls,
        Set<Attribute> nonDataTypeAttribs)
    {
        Map<Attribute, ComponentInfo> componentInfoMap =
            new LinkedHashMap<Attribute, ComponentInfo>();
        if (componentAttribMap.containsKey(cls)) {
            for(ComponentInfo componentInfo: componentAttribMap.get(cls)) {
                componentInfoMap.put(
                    componentInfo.getOwnerAttribute(), componentInfo);
            }
        }
        for(Attribute attrib: nonDataTypeAttribs) {
            componentInfoMap.put(
                attrib,
                new ComponentInfo(cls, attrib, true));
        }
        return componentInfoMap;
    }

    private Map<Reference, ReferenceInfo> buildRefInfoMap(
        Collection<Reference> instanceReferences)
        throws GenerationException
    {
        Map<Reference, ReferenceInfo> refInfoMap =
            new HashMap<Reference, ReferenceInfo>();
        for(Reference ref: instanceReferences) {
            ReferenceInfo refInfo = new ReferenceInfoImpl(ref);
            refInfoMap.put(ref, refInfo);
        }
        return refInfoMap;
    }

    /**
     * Adds the given {@link ComponentInfo component attribute reference} to
     * the given component type in {@link #componentAttribMap}.
     * 
     * @param type component type 
     * @param compInfo component attribute reference
     */
    private void addComponentAttrib(
        Classifier type, ComponentInfo compInfo)
    {
        List<ComponentInfo> componentOfList = componentAttribMap.get(type);
        
        if (componentOfList == null) {
            componentOfList = new ArrayList<ComponentInfo>();
            componentAttribMap.put(type, componentOfList);
        }
        
        componentOfList.add(compInfo);
    }

    /**
     * Generates an implementation of {@link RefObject#refImmediateComposite()}
     * for the given {@link MofClass}.
     * 
     * @param cls MofClass being generated
     * @param refInfoMap map of referenced
     * @param unrefAssocInfoMap map of unreferenced associations
     * @param componentInfoMap map of component types
     * @throws GenerationException if there's an error generating the method
     */
    private void generateRefImmediateComposite(
        MofClass cls,
        Map<Reference, ReferenceInfo> refInfoMap,
        Map<Association, ReferenceInfo> unrefAssocInfoMap,
        Map<Attribute, ComponentInfo> componentInfoMap)
    throws GenerationException
    {
        newLine();
        startBlock(
            "public ", REF_OBJECT_CLASS, " refImmediateComposite()");
        
        writeln("logJmi(", QUOTE, "refImmediateComposite", QUOTE, ");");
        
        // Find the composite associations, if any.  Note that MOF states
        // an object is only allowed to be the component end of a single
        // composite aggregation at a time, so we just traverse all of 
        // the composite aggregates and assume that only one will be valid.
        // This is not presently enforced, however.
        for(ReferenceInfo refInfo: refInfoMap.values()) {                        
            if (refInfo.isComposite()) {
                startConditionalBlock(
                    CondType.IF,
                    getReferenceAccessorName(refInfo), "() != null");
                write(
                    "return ", 
                    CodeGenUtils.getAccessorName(generator, refInfo.getReference()), "()");
                if (!refInfo.isSingle()) {
                    if (refInfo.isOrdered()) {
                        write(".get(0)");
                    } else {
                        write(".iterator().next()");
                    }
                }
                writeln(";");
                endBlock();
            }
        }
        
        for(ReferenceInfo refInfo: unrefAssocInfoMap.values()) {            
            if (refInfo.isComposite()) {
                startConditionalBlock(
                    CondType.IF,
                    getReferenceAccessorName(refInfo), "() != null");
                write(
                    "return ", 
                    getReferenceAccessorName(refInfo), "()");
                
                switch(refInfo.getKind()) {
                case ONE_TO_ONE:
                    if (refInfo.isReferencedEndFirst()) {
                        write(".getParent()");
                    } else {
                        write(".getChild()");
                    }
                    break;
                    
                case ONE_TO_MANY:
                    if (refInfo.isSingle()) {
                        write(".getParent()");
                    } else if (refInfo.isOrdered()) {
                        write(".getChildren().get(0)");
                    } else {
                        write(".getChildren().iterator.next()");
                    }
                    break;
                    
                case MANY_TO_MANY:
                    if (refInfo.isOrdered()) {
                        write(".getTarget().get(0)");
                    } else {
                        write(".getTarget().iterator().next()");
                    }
                    break;
                    
                default:
                    throw new GenerationException("unknown assoc kind");
                }
                
                writeln(";");
                endBlock();
            }
        }

        for(Map.Entry<Attribute, ComponentInfo> entry: 
                componentInfoMap.entrySet()) 
        {
            ComponentInfo componentInfo = entry.getValue();
            
            if (!componentInfo.getOwnerType().equals(cls)) {
                startConditionalBlock(
                    CondType.IF,
                    getReferenceAccessorName(componentInfo), "() != null");

                write(
                    "return ", getReferenceAccessorName(componentInfo), "()");
                
                switch(componentInfo.getKind()) {
                case ONE_TO_ONE:
                case ONE_TO_MANY:
                    write(".getParent()");
                    break;
                    
                case MANY_TO_MANY:
                    write(".getSource()");
                    break;
                    
                default:
                    throw new GenerationException("unknown assoc kind");
                }
                
                writeln(";");
                endBlock();
            }
        }
        
        // no composite associations (or none in use)
        writeln("return null;");
        
        endBlock();
    }

    /**
     * Generates an implementation of 
     * {@link HibernateAssociable#getAssociation(String, boolean)} for the
     * described references.  Delegates to 
     * {@link #generateGenericAssociationMethod(List, AssocMethodGenerator)}.
     * 
     * @param refInfos descriptions of {@link Reference} instances which must
     *                 be handled by the generated method
     * @throws GenerationException if there's an error generating the method
     */
    private void generateGetAssociationMethod(List<ReferenceInfo> refInfos)
        throws GenerationException
    {
        writeln("// Implement HibernateAssociable");
        startBlock(
            "public ",
            ASSOCIATION_INTERFACE,
            " getAssociation(String type, boolean firstEnd)");

        generateGenericAssociationMethod(
            refInfos,
            new AssocMethodGenerator() {
                public void generate(ReferenceInfo refInfo)
                    throws GenerationException
                {
                    writeln(
                        "return ", getReferenceAccessorName(refInfo), "();");
                }
                
            });
        
        endBlock();
    }

    /**
     * Generates an implementation of 
     * {@link HibernateAssociable#setAssociation(String, boolean, HibernateAssociation)}
     * for the described references.  Delegates to 
     * {@link #generateGenericAssociationMethod(List, AssocMethodGenerator)}.
     * 
     * @param refInfos descriptions of {@link Reference} instances which must
     *                 be handled by the generated method
     * @throws GenerationException if there's an error generating the method
     */
    private void generateSetAssociationMethod(List<ReferenceInfo> refInfos)
        throws GenerationException
    {
        writeln("// Implement HibernateAssociable");
        startBlock(
            "public void setAssociation(String type, boolean firstEnd, ",
            ASSOCIATION_INTERFACE, " assoc)");

        generateGenericAssociationMethod(
            refInfos, 
            new AssocMethodGenerator() {
                public void generate(ReferenceInfo refInfo)
                    throws GenerationException
                {
                    writeln(
                        getReferenceMutatorName(refInfo),
                        "((",
                        makeType(refInfo),
                        ")assoc);");
                    writeln("return;");
                }
            });
        
        endBlock();
    }

    /**
     * Generates an implementation of 
     * {@link HibernateAssociable#getOrCreateAssociation(String, boolean)}
     * for the described references.  Delegates to 
     * {@link #generateGenericAssociationMethod(List, AssocMethodGenerator)}.
     * 
     * @param refInfos descriptions of {@link Reference} instances which must
     *                 be handled by the generated method
     * @throws GenerationException if there's an error generating the method
     */
    private void generateGetOrCreateAssociationMethod(
        List<ReferenceInfo> refInfos)
    throws GenerationException
    {
        writeln("// Implement HibernateAssociable");
        startBlock(
            "public ",
            ASSOCIATION_INTERFACE,
            " getOrCreateAssociation(String type, boolean firstEnd)");

        generateGenericAssociationMethod(
            refInfos, 
            new AssocMethodGenerator() {
                public void generate(ReferenceInfo refInfo)
                    throws GenerationException
                {
                    writeln(
                        makeType(refInfo), " assoc = ",
                        getReferenceAccessorName(refInfo), "();");
                    
                    startConditionalBlock(CondType.IF, "assoc == null");
                        
                    writeln(
                        "assoc = new ",
                        makeType(refInfo),
                        "();");
                    writeln("assoc.setType(type);");
                    
                    // Set up the local end of the association.
                    switch(refInfo.getKind()) {
                    case ONE_TO_ONE:
                        if (refInfo.isExposedEndFirst()) {
                            writeln("assoc.setInitialParent(this);");
                        } else {
                            writeln("assoc.setInitialChild(this);");
                        }
                        break;
                        
                    case ONE_TO_MANY:
                        boolean hasParent = refInfo.isSingle();
                        if (!hasParent) {
                            writeln("assoc.setInitialParent(this);");
                        } else {
                            writeln("assoc.addInitialChild(this);");
                        }
                        writeln(
                            "assoc.setReversed(", refInfo.isSingle(1), ");");
                        break;

                    case MANY_TO_MANY:
                        writeln("assoc.setInitialSource(this);");
                        writeln("assoc.setReversed(!firstEnd);");
                        break;
                    }
                    
                    writeln(getReferenceMutatorName(refInfo), "(assoc);");
                    writeln("assoc.save();");
                    endBlock();
                    writeln("return assoc;");
                } 
            });

        endBlock();
    }

    /**
     * Generates an implementation of 
     * {@link HibernateAssociable#getAssociation(String, boolean)} for the
     * described references.  Delegates to 
     * {@link #generateGenericAssociationMethod(List, AssocMethodGenerator)}.
     * 
     * @param refInfos descriptions of {@link Reference} instances which must
     *                 be handled by the generated method
     * @throws GenerationException if there's an error generating the method
     */
    private void generateGetAssociationColumnNameMethod(
        List<ReferenceInfo> refInfos)
    throws GenerationException
    {
        writeln("// Implement HibernateAssociable");
        startBlock(
            "public String getAssociationColumnName(String type, boolean firstEnd)");

        generateGenericAssociationMethod(
            refInfos,
            new AssocMethodGenerator() {
                public void generate(ReferenceInfo refInfo)
                    throws GenerationException
                {
                    String columnName = 
                        StringUtil.toInitialLower(
                            generator.transformIdentifier(
                                refInfo.getReferencedEndBaseName()));
                    writeln(
                        "return ", 
                        QUOTE, columnName, QUOTE, ";");
                }                
            });
        
        endBlock();
    }
    
    /**
     * Generates an association method generically based on the described
     * references and {@link AssocMethodGenerator}.
     * 
     * @param refInfos descriptions of {@link Reference} instances that the
     *                 generated method must handle
     * @param assocMethodGenerator generator class for the method
     * @throws GenerationException if there's an error generating the method
     */
    private void generateGenericAssociationMethod(
        List<ReferenceInfo> refInfos,
        AssocMethodGenerator assocMethodGenerator) 
    throws GenerationException
    {
        List<ReferenceInfo> firstEndsExposed = new ArrayList<ReferenceInfo>();
        List<ReferenceInfo> secondEndsExposed = new ArrayList<ReferenceInfo>();
        for(ReferenceInfo refInfo: refInfos) {
            if (refInfo.isExposedEndFirst()) {
                firstEndsExposed.add(refInfo);
            } else {
                secondEndsExposed.add(refInfo);
            }
        }
        
        boolean firstFirstEnd = true;
        for(ReferenceInfo refInfo: firstEndsExposed) {
            if (firstFirstEnd) {
                startConditionalBlock(CondType.IF, "firstEnd");
            }
            startConditionalBlock(
                firstFirstEnd ? CondType.IF : CondType.ELSEIF,
                QUOTE,
                refInfo.getBaseName(),
                QUOTE,
                ".equals(type)");
            assocMethodGenerator.generate(refInfo);
            firstFirstEnd = false;
        }
        if (!firstFirstEnd) {
            endBlock();
        }
        
        boolean firstSecondEnd = true;
        for(ReferenceInfo refInfo: secondEndsExposed) {
            if (firstSecondEnd) {
                if (firstFirstEnd) {
                    // No first ends
                    startConditionalBlock(CondType.IF, "!firstEnd");
                } else {
                    startConditionalBlock(CondType.ELSE);
                }
            }
            startConditionalBlock(
                firstSecondEnd ? CondType.IF : CondType.ELSEIF,
                QUOTE,
                refInfo.getBaseName(),
                QUOTE,
                ".equals(type)");
            assocMethodGenerator.generate(refInfo);
            firstSecondEnd = false;
        }
        if (!firstSecondEnd) {
            endBlock();
        }
        endBlock();
        
        newLine();

        writeln(
            "throw new IllegalArgumentException(",
            QUOTE, "Unknown assoc type '", QUOTE,
            " + type + ", QUOTE, "' for 'end ", QUOTE,
            " + (firstEnd ? 1 : 2) + ", QUOTE, "'", QUOTE, ");");
    }

    /**
     * Generates an implementation of the 
     * {@link HibernateRefObject#removeAssociations} method.  Associations
     * are remove in strict order:
     * <ol>
     * <li>Composite attributes (see {@link ComponentInfo})</li>
     * <li>Super-type association ends</li>
     * <li>Current class association ends</li>
     * <li>Composite owner associations</li>
     * </ol>
     * 
     * @param cls the class being generated
     * @param refInfos descriptions of {@link Reference} instances which must
     *                 be handled by the generated method
     * @throws GenerationException if there's an error generating the method
     */
    private void generateRemoveAssociationMethod(
        MofClass cls, List<ReferenceInfo> refInfos)
    throws GenerationException
    {
        newLine();
        writeln("// Implement HibernateRefObject");
        startBlock("protected void removeAssociations()");

        if (refInfos == null) {
            endBlock();
            return;
        }

        boolean generatedVar = false;
        
        // Associations are removed in a specific order (which matches Netbeans
        // MDR):
        // 1. composite attribute(s) (in order of appearance in code)
        // 2. super-type association ends
        // 3. this class's association ends
        // 4. remove this class from its composite owner
        
        // Super-types are traversed in the order given by cls.getSupertypes(),
        // ignoring repeats.
        
        // AssociationEnds within a class are ordered first by their containing
        // Association (in the order in which it is returned by recursive
        // traversal of MofPackage contents) and then by end number.
        
        writeln("// Composite Attributes");
        List<ReferenceInfo> assocRefInfos = new ArrayList<ReferenceInfo>();
        for(ReferenceInfo refInfo: refInfos) {
            boolean isComponentAttrib = refInfo instanceof ComponentInfo;
            if (isComponentAttrib) {
                // ComponentInfo always has the composite owner as the first
                // end.  If this class is the owner, generate the cascade
                // delete (and remove our internal association link).
                // We'll pick the rest up later (step 4).
                if (refInfo.isExposedEndFirst()) {
                    generatedVar = 
                        generateRemoveAssociationClause(
                            refInfo, generatedVar, true, false);
                }
            } else {
                assocRefInfos.add(refInfo);
            }
        }

        newLine();
        writeln("// References/Associations");
        // Step 2/3.  First determine the global association end ordering,
        // if it hasn't been done already.
        if (assocEndOrderMap.isEmpty()) {
            List<AssociationEnd> orderedEnds = new ArrayList<AssociationEnd>();
            for(AssociationInfo assocInfo: assocInfoMap.values()) {
                orderedEnds.add(assocInfo.getEnd(0));
                orderedEnds.add(assocInfo.getEnd(1));
            }

            for(int i = 0; i < orderedEnds.size(); i++) {
                // Don't use 0 as an ordinal: we check for it later in the
                // comparator.
                assocEndOrderMap.put(orderedEnds.get(i), i + 1);
            }
        } else {
            assert(assocEndOrderMap.size() == assocInfoMap.size() * 2);
        }
        
        // Step 2/3 continued: Compute the type ordering (including the
        // current class).
        Map<Classifier, Integer> typeOrderMap = 
            new HashMap<Classifier, Integer>();
        int ordinal = 0;
        for(Classifier supertype: collectSupertypes(cls)) {
            // Don't use ordinal 0: we use it to check for missing types
            // in the comparator
            typeOrderMap.put(supertype, ++ordinal);
        }

        // Step 2/3 continued: sort the associations ends and generate code.
        Collections.sort(
            assocRefInfos, 
            new AssociationRemoveOrderComparator(
                typeOrderMap, assocEndOrderMap));

        for(ReferenceInfo refInfo: assocRefInfos) {
            boolean cascadeRefDelete = 
                refInfo.isComposite(refInfo.getExposedEndIndex());

            generatedVar =
                generateRemoveAssociationClause(
                    refInfo, generatedVar, cascadeRefDelete, true);
        }

        // Step 4.  Go back and remove associations to composite owners.
        newLine();
        writeln("// Composite owners");
        for(ReferenceInfo refInfo: refInfos) {
            boolean isComponentAttrib = refInfo instanceof ComponentInfo;
            if (isComponentAttrib && !refInfo.isExposedEndFirst()) {
                generatedVar =
                    generateRemoveAssociationClause(
                        refInfo, generatedVar, false, false);
            }
        }
        
        endBlock();
    }

    /**
     * Generates a clause that removes a particular {@link Reference}'s 
     * association links, with or without cascading deletion of linked
     * references and association remove events.
     * 
     * @param refInfo the description of a particular {@link Reference}
     * @param generatedVar previous return value from this method, indicating
     *                     whether a temporary variable for associations was 
     *                     was generated or not (pass false on first 
     *                     invocation)
     * @param cascadeRefDelete if true, generate cascading delete of
     *                         associated instances
     * @param generateRemoveAssociationEvents if true, generates association
     *                                        remove events
     * @throws GenerationException if there's an error generating code
     */
    private boolean generateRemoveAssociationClause(
        ReferenceInfo refInfo,
        boolean generatedVar,
        boolean cascadeRefDelete,
        boolean generateRemoveAssociationEvents)
    throws GenerationException
    {
        if (!generatedVar) {
            write(ASSOCIATION_INTERFACE, " ");
        }
        writeln(
            "assoc = ", 
            getReferenceAccessorName(refInfo), "();");

        startConditionalBlock(CondType.IF, "assoc != null");
        if (generateRemoveAssociationEvents) {
            writeln(
                "super.fireAssociationRemoveAllEvents(",
                QUOTE, getAssociationIdentifier(refInfo.getAssoc()), QUOTE, 
                ", ",
                refInfo.isExposedEndFirst(), ", assoc);");            
        }
        writeln(
            "assoc.removeAll(this, ", 
            refInfo.isExposedEndFirst(), ", ", 
            cascadeRefDelete, ");");
        endBlock();
        
        return true;
    }

    /**
     * Generates an implementation of the 
     * {@link HibernateRefObject#getComposingAssociations()} method.
     * 
     * @param cls the class being generated
     * @param refInfos descriptions of {@link Reference} instances which must
     *                 be handled by the generated method
     * @throws GenerationException if there's an error generating the method
     */
    private void generateGetComposingAssociationsMethod(
        MofClass cls, List<ReferenceInfo> refInfos)
    throws GenerationException
    {
        newLine();
        writeln("// Implement HibernateRefObject");
        startBlock(
            "public ", 
            JAVA_UTIL_COLLECTION_CLASS,
            "<", ASSOCIATION_INTERFACE, "> getComposingAssociations()");

        if (refInfos == null) {
            writeln("return ", JAVA_UTIL_COLLECTIONS_CLASS, ".emptySet();");
            endBlock();
            return;
        }

        List<ReferenceInfo> compInfos = new ArrayList<ReferenceInfo>();
        for(ReferenceInfo refInfo: refInfos) {
            // ComponentInfo always has the composite owner as the first
            // end.  If this class is the owner, we want to return the
            // association.
            if (refInfo instanceof ComponentInfo) {
                if (refInfo.isExposedEndFirst()) {
                    compInfos.add(refInfo);
                }
            } else if (refInfo.isComposite(refInfo.getExposedEndIndex())) {
                compInfos.add(refInfo);
            }
        }

        if (compInfos.size() == 0) {
            writeln("return ", JAVA_UTIL_COLLECTIONS_CLASS, ".emptySet();");
        } else {
            writeln(
                JAVA_UTIL_LIST_CLASS, "<", ASSOCIATION_INTERFACE, "> result = ",
                "new ", JAVA_UTIL_ARRAYLIST_CLASS, "<", ASSOCIATION_INTERFACE, ">(",
                compInfos.size(), ");");
            boolean first = true;
            for(ReferenceInfo compInfo: compInfos) {
                if (first) {
                    write(ASSOCIATION_INTERFACE, " ");
                    first = false;
                }

                writeln("assoc = ", getReferenceAccessorName(compInfo), "();");
                startConditionalBlock(CondType.IF, "assoc != null");
                writeln("result.add(assoc);");
                endBlock();
            }
    
            writeln("return result;");
        }
        endBlock();
    }

    /**
     * Generates an implementation of the 
     * {@link HibernateRefObject#getNonComposingAssociations()} method.
     * 
     * @param cls the class being generated
     * @param refInfos descriptions of {@link Reference} instances which must
     *                 be handled by the generated method
     * @throws GenerationException if there's an error generating the method
     */
    private void generateGetNonComposingAssociationsMethod(
        MofClass cls, List<ReferenceInfo> refInfos)
    throws GenerationException
    {
        newLine();
        writeln("// Implement HibernateRefObject");
        startBlock(
            "public ", 
            JAVA_UTIL_COLLECTION_CLASS,
            "<", ASSOCIATION_INTERFACE, "> getNonComposingAssociations()");

        if (refInfos == null) {
            writeln("return ", JAVA_UTIL_COLLECTIONS_CLASS, ".emptySet();");
            endBlock();
            return;
        }

        List<ReferenceInfo> nonCompInfos = new ArrayList<ReferenceInfo>();
        for(ReferenceInfo refInfo: refInfos) {
            // ComponentInfo always has the composite owner as the first
            // end.  If this class is not the owner, we want to return the
            // association.
            if (refInfo instanceof ComponentInfo) {
                if (refInfo.isExposedEndFirst()) {
                    continue;
                }
            } else if (refInfo.isComposite(refInfo.getExposedEndIndex())) {
                continue;
            }

            nonCompInfos.add(refInfo);
        }

        if (nonCompInfos.size() == 0) {
            writeln("return ", JAVA_UTIL_COLLECTIONS_CLASS, ".emptySet();");
        } else {
            writeln(
                JAVA_UTIL_LIST_CLASS, "<", ASSOCIATION_INTERFACE, "> result = ",
                "new ", JAVA_UTIL_ARRAYLIST_CLASS, "<", ASSOCIATION_INTERFACE, ">(",
                nonCompInfos.size(), ");");
            boolean first = true;
            for(ReferenceInfo refInfo: nonCompInfos) {
                if (first) {
                    write(ASSOCIATION_INTERFACE, " ");
                    first = false;
                }
    
                writeln("assoc = ", getReferenceAccessorName(refInfo), "();");
                startConditionalBlock(CondType.IF, "assoc != null");
                writeln("result.add(assoc);");
                endBlock();
            }
            
            writeln("return result;");
        }
        endBlock();
    }

    /**
     * Gather together a List of {@link ReferenceInfo} instances from the
     * given parameters.
     */
    private List<ReferenceInfo> gatherRefInfos(
        Collection<Reference> instanceReferences,
        Map<Reference, ReferenceInfo> refInfoMap,
        Collection<Association> unreferencedAssociations,
        Map<Association, ReferenceInfo> unrefAssocRefInfoMap,
        Map<Attribute, ComponentInfo> componentInfoMap)
    {
        List<ReferenceInfo> refInfos = new ArrayList<ReferenceInfo>();
        for(Reference ref: instanceReferences) {
            ReferenceInfo refInfo = refInfoMap.get(ref);
            refInfos.add(refInfo);
        }
        for(Association unrefAssociation: unreferencedAssociations) {
            ReferenceInfo refInfo = unrefAssocRefInfoMap.get(unrefAssociation);
            refInfos.add(refInfo);
        }
        refInfos.addAll(componentInfoMap.values());
        return refInfos;
    }

    /**
     * Generates public API accessors and mutators and Hibernate
     * accessors and mutators for the given references.   Public API 
     * mutators are not generated unless the {@link Reference} is 
     * changeable.
     * 
     * @param instanceReferences all class instance 
     *                           {@link Reference references}
     * @param refInfoMap map of {@link Reference} to {@link ReferenceInfo}
     * @throws GenerationException if there's an error generating the methods
     */
    private void generateClassInstanceRefMethods(
        Collection<Reference> instanceReferences,
        Map<Reference, ReferenceInfo> refInfoMap)
        throws GenerationException
    {
        for(Reference ref: instanceReferences) {
            newLine();

            ReferenceInfo refInfo = refInfoMap.get(ref);
            if (refInfo == null) {
                throw new GenerationException(
                    "unknown reference '" + ref.getName() + "'");
            }
            
            switch(refInfo.getKind()) {
            case ONE_TO_ONE:
                generateClassInstanceRefOneToOneMethods(ref, refInfo);
                break;
            
            case ONE_TO_MANY: 
                generateClassInstanceRefOnetoManyMethods(ref, refInfo);
                break;
            
            case MANY_TO_MANY:
                generateClassInstanceRefManyToManyMethods(ref, refInfo);
                break;
                
            default:
                throw new GenerationException(
                    "Unknown reference type: " + refInfo.getKind());
            }

            generateClassInstanceAssocMethods(refInfo);
        }
    }

    /**
     * Generates public API accessors and mutators and Hibernate
     * accessors and mutators for the given component attributes.  Public API
     * methods are only generated for an {@link Attribute} passed as a key in
     * the map if that attribute is a member of the class being generated.
     * Other wise only the internal {@link HibernateAssociation} methods
     * are generated. 
     * 
     * @param componentInfoMap map of {@link Attribute component attributes}
     *                         to {@link ComponentInfo}. 
     * @param cls {@link MofClass} being generated.
     * @throws GenerationException if there's an error generating the methods
     */
    private void generateClassInstanceComponentMethods(
        Map<Attribute, ComponentInfo> componentInfoMap,
        MofClass cls)
    throws GenerationException
    {
        for(Map.Entry<Attribute, ComponentInfo> entry:
                componentInfoMap.entrySet()) 
        {
            Attribute attrib = entry.getKey();
            ComponentInfo componentInfo = entry.getValue();

            if (componentInfo.getOwnerType().equals(cls)) {
                newLine();
    
                switch(componentInfo.getKind()) {
                case ONE_TO_ONE:
                    generateClassInstanceComponentRefOneToOneMethods(
                        attrib, componentInfo);
                    break;
                
                case ONE_TO_MANY: 
                    generateClassInstanceComponentRefOneToManyMethods(
                        attrib, componentInfo);
                    break;
                
                case MANY_TO_MANY:
                    throw new GenerationException(
                        "Unsupported: many-to-many component attributes");
                    
                default:
                    throw new GenerationException(
                        "Unknown component type: " + componentInfo.getKind());
                }
            }
            
            generateClassInstanceAssocMethods(componentInfo);
        }
    }
    
    /**
     * Generates the internal {@link HibernateAssociation} accessor and
     * mutator methods for a {@link Reference}.
     * 
     * @param refInfo Reference description
     */
    private void generateClassInstanceAssocMethods(ReferenceInfo refInfo)
        throws GenerationException
    {
        newLine();
        writeln("// Internal use only");
        startBlock(
            "public ",
            makeType(refInfo),
            " ",
            getReferenceAccessorName(refInfo),
            "()");
        writeln(
            "return ", 
            generator.transformIdentifier(refInfo.getFieldName()), IMPL_SUFFIX,
            ";");
        endBlock();
        
        newLine();
        writeln("// Internal use only");
        startBlock(
            "public void ",
            getReferenceMutatorName(refInfo),
            "(",
            makeType(refInfo),
            " newValue)");
        writeln(
            "this.", 
            generator.transformIdentifier(refInfo.getFieldName()), IMPL_SUFFIX,
            " = newValue;");
        endBlock();
    }

    /**
     * Generates public API accessor and mutator methods for the given
     * {@link Reference} to a 1-to-1 {@link Association}.  Mutators are
     * only generated if the reference is changeable.
     * 
     * @param ref the Reference
     * @param refInfo description of the Reference
     * @throws GenerationException if there's an error generating the methods
     */
    private void generateClassInstanceRefOneToOneMethods(
        Reference ref,
        ReferenceInfo refInfo)
    throws GenerationException
    {
        startAccessorBlock(ref);

        writeln(
            "logJmi(", 
            QUOTE, CodeGenUtils.getAccessorName(generator, ref), QUOTE, ");");

        writeln(
            makeType(refInfo), " assoc = ", 
            getReferenceAccessorName(refInfo), "();");
        
        startConditionalBlock(CondType.IF, "assoc == null");
        writeln("return null;");
        endBlock();

        writeln(
            "return assoc.get", getReferenceEndName(refInfo, true),
            "(",
            refInfo.getReferencedTypeName(),
            ".class",
            ");");
        endBlock();
        
        if (ref.isChangeable()) {
            newLine();
            startMutatorBlock(ref);
            
            writeln(
                "logJmi(", 
                QUOTE, CodeGenUtils.getMutatorName(generator, ref), QUOTE, ");");
            
            writeln(
                "super.associationSetSingle(", 
                QUOTE, refInfo.getBaseName(), QUOTE, ", ", 
                QUOTE, getAssociationIdentifier(refInfo.getAssoc()), QUOTE, 
                ", ", refInfo.isExposedEndFirst(), ", (",
                ASSOCIABLE_INTERFACE, ")newValue);");
            endBlock();
        }
    }

    /**
     * Generates public API accessor and mutator methods for the given
     * {@link Reference} to a 1-to-many {@link Association}.  Mutators are
     * only generated if the reference is changeable and the referenced end
     * is single.
     * 
     * @param ref the Reference
     * @param refInfo description of the Reference
     * @throws GenerationException if there's an error generating the methods
     */
    private void generateClassInstanceRefOnetoManyMethods(
        Reference ref,
        ReferenceInfo refInfo)
    throws GenerationException
    {
        startAccessorBlock(ref);

        writeln(
            "logJmi(", 
            QUOTE, CodeGenUtils.getAccessorName(generator, ref), QUOTE, ");");

        boolean hasParent = ref.getMultiplicity().getUpper() == 1;
        if (hasParent) {
            writeln(
                makeType(refInfo), " assoc = ", 
                getReferenceAccessorName(refInfo), "();");
            
            startConditionalBlock(CondType.IF, "assoc == null");
            writeln("return null;");
            endBlock();
            writeln(
                "return (",
                refInfo.getEndType(refInfo.isSingle(0) ? 0 : 1),                            
                ")assoc.getParent();");
        } else {
            String listElemType = 
                refInfo.getEndType(refInfo.isSingle(0) ? 1 : 0);
            
            JavaClassReference proxyRef = COLLECTION_PROXY_CLASS;
            if (refInfo.isOrdered()) {
                proxyRef = LIST_PROXY_CLASS;
            }
            
            writeln(
                makeType(refInfo), " assoc = ", 
                getReferenceAccessorName(refInfo), "();");
            
            startConditionalBlock(CondType.IF, "assoc == null");
            writeln(
                "return new ", 
                proxyRef,
                "<", listElemType, ">",
                "(", QUOTE, refInfo.getBaseName(), QUOTE,
                ", this, ",
                refInfo.isExposedEndFirst(), ", ",
                QUOTE, getAssociationIdentifier(refInfo.getAssoc()), QUOTE, ", ",
                listElemType, ".class);");
            startConditionalBlock(CondType.ELSE);
            writeln(
                "return new ",
                proxyRef,
                "<", listElemType, ">",
                "(assoc, this, ",
                refInfo.isExposedEndFirst(), ", ",
                QUOTE, getAssociationIdentifier(refInfo.getAssoc()), QUOTE, ", ",
                listElemType, ".class);");
            endBlock();
        }
        endBlock();
        
        if (hasParent && ref.isChangeable()) {
            newLine();
            startMutatorBlock(ref);
            
            writeln(
                "logJmi(", 
                QUOTE, CodeGenUtils.getMutatorName(generator, ref), QUOTE, ");");
            
            writeln(
                "super.associationSetSingle(", 
                QUOTE, refInfo.getBaseName(), QUOTE, ", ", 
                QUOTE, getAssociationIdentifier(refInfo.getAssoc()), QUOTE, 
                ", ", refInfo.isExposedEndFirst(), ", (",
                ASSOCIABLE_INTERFACE, ")newValue);");
            endBlock();
        }
    }

    /**
     * Generates public API accessor method for the given {@link Reference} to 
     * a many-to-many {@link Association}.
     * 
     * @param ref the Reference
     * @param refInfo description of the Reference
     * @throws GenerationException if there's an error generating the method
     */
    private void generateClassInstanceRefManyToManyMethods(
        Reference ref,
        ReferenceInfo refInfo)
    throws GenerationException
    {
        startAccessorBlock(ref);

        writeln(
            "logJmi(", 
            QUOTE, CodeGenUtils.getAccessorName(generator, ref), QUOTE, ");");

        String listElemType = 
            getReferenceEndType(refInfo, true);
        
        writeln(
            makeType(refInfo), " assoc = ", 
            getReferenceAccessorName(refInfo), "();");
        
        startConditionalBlock(CondType.IF, "assoc == null");
        
        JavaClassReference proxyRef = COLLECTION_PROXY_CLASS;
        if (refInfo.isOrdered()) {
            proxyRef = LIST_PROXY_CLASS;
        }
        
        writeln(
            "return new ", 
            proxyRef, "<", listElemType, ">",
            "(", QUOTE, refInfo.getBaseName(), QUOTE,
            ", this, ",
            refInfo.isExposedEndFirst(), ", ", 
            QUOTE, getAssociationIdentifier(refInfo.getAssoc()), QUOTE, ", ",
            listElemType, ".class);");
        startConditionalBlock(CondType.ELSE);
        writeln(
            "return new ",
            proxyRef, "<", listElemType, ">",
            "(assoc, this, ",
            refInfo.isExposedEndFirst(), ", ",
            QUOTE, getAssociationIdentifier(refInfo.getAssoc()), QUOTE, ", ",
            listElemType, ".class);");
        endBlock();
        endBlock();
    }

    /**
     * Generates public API accessor and mutator methods for the given
     * {@link Attribute component attribute} with 1-to-1 multiplicity.
     * 
     * @param attrib the {@link Attribute}
     * @param compInfo description of the component Attribute
     * @throws GenerationException if there's an error generating the methods
     */
    private void generateClassInstanceComponentRefOneToOneMethods(
        Attribute attrib, ComponentInfo compInfo)
    {
        startAccessorBlock(attrib);
        
        writeln(
            "logJmi(", 
            QUOTE, CodeGenUtils.getAccessorName(generator, attrib), QUOTE, ");");

        startConditionalBlock(
            CondType.IF,
            getReferenceAccessorName(compInfo), "() == null");
        writeln("return null;");
        endBlock();

        writeln(
            "return ", 
            getReferenceAccessorName(compInfo),
            "().get", getReferenceEndName(compInfo, true),
            "(",
            compInfo.getReferencedTypeName(),
            ".class",
            ");");
        endBlock();
        
        newLine();
        startMutatorBlock(attrib);
            
        writeln(
            "logJmi(", 
            QUOTE, CodeGenUtils.getMutatorName(generator, attrib), QUOTE, ");");
        
        writeln(
            "super.attributeSetSingle(", 
            QUOTE, compInfo.getBaseName(), QUOTE, ", ", 
            QUOTE, attrib.getName(), QUOTE, 
            ", ", compInfo.isExposedEndFirst(), ", (",
            ASSOCIABLE_INTERFACE, ")newValue);");
        
        endBlock();                        
    }

    /**
     * Generates public API accessor and mutator methods for the given
     * {@link Attribute component attribute} with 1-to-many multiplicity.
     * 
     * @param attrib the {@link Attribute}
     * @param compInfo description of the component Attribute
     * @throws GenerationException if there's an error generating the methods
     */
    private void generateClassInstanceComponentRefOneToManyMethods(
        Attribute attrib, ComponentInfo compInfo)
    throws GenerationException
    {
        startAccessorBlock(attrib);

        writeln(
            "logJmi(", 
            QUOTE, CodeGenUtils.getAccessorName(generator, attrib), QUOTE, ");");
        
        boolean hasParent = compInfo.isSingle(compInfo.getReferencedEndIndex());
        if (hasParent) {
            startConditionalBlock(
                CondType.IF, 
                getReferenceAccessorName(compInfo), "() == null");
            writeln("return null;");
            endBlock();
            writeln(
                "return (",
                compInfo.getEndType(compInfo.isSingle(0) ? 0 : 1),                            
                ")", 
                getReferenceAccessorName(compInfo), 
                "().getParent();");
        } else {
            String listElemType = 
                compInfo.getEndType(compInfo.isSingle(0) ? 1 : 0);
            
            JavaClassReference proxyRef = ATTRIB_COLLECTION_PROXY_CLASS;
            if (compInfo.isOrdered()) {
                proxyRef = ATTRIB_LIST_PROXY_CLASS;
            }
            
            startConditionalBlock(
                CondType.IF, 
                getReferenceAccessorName(compInfo), "() == null");
            writeln(
                "return new ", 
                proxyRef,
                "<", listElemType, ">",
                "(", QUOTE, compInfo.getBaseName(), QUOTE,
                ", this, ", compInfo.isExposedEndFirst(), ", ",
                QUOTE, attrib.getName(), QUOTE, ", ",
                listElemType, ".class);");
            startConditionalBlock(CondType.ELSE);
            writeln(
                "return new ",
                proxyRef,
                "<", listElemType, ">",
                "(",
                getReferenceAccessorName(compInfo),
                "(), this, ",
                compInfo.isExposedEndFirst(), ", ",
                QUOTE, attrib.getName(), QUOTE, ", ",
                listElemType, ".class);");
            endBlock();
        }
        endBlock();
        
        if (hasParent) {
            newLine();
            startMutatorBlock(attrib);

            writeln(
                "logJmi(", 
                QUOTE, CodeGenUtils.getMutatorName(generator, attrib), QUOTE, ");");
            
            writeln(
                "super.attributeSetSingle(", 
                QUOTE, compInfo.getBaseName(), QUOTE, ", ", 
                QUOTE, attrib.getName(), QUOTE, 
                ", ", compInfo.isExposedEndFirst(), ", (",
                ASSOCIABLE_INTERFACE, ")newValue);");

            endBlock();                        
        }
    }

    /**
     * Generates constructors for a class instance implementation.  A zero
     * argument constructor is always generated.  A constructor with parameters
     * is constructed if there are 1 or more instance attributes.
     * 
     * @param cls {@link MofClass} being generated
     * @param instanceAttributes instance attributes (including those inherited
     *                           from super classes)
     * @param nonDerivedAttribs list of non-derived Attributes
     * @param nonDerivedAttribNames map of non-derived Attributes to their 
     *                              field names.
     * @param nonDataTypeAttribs set of component Attributes
     * @param componentInfoMap details about component attributes
     */
    private void generateClassInstanceConstructors(
        MofClass cls,
        Collection<Attribute> instanceAttributes,
        ArrayList<Attribute> nonDerivedAttribs,
        Map<Attribute, String> nonDerivedAttribNames,
        Set<Attribute> nonDataTypeAttribs,
        Map<Attribute, ComponentInfo> componentInfoMap)
    {
        // zero argument constructor
        startConstructorBlock(cls, null, null, IMPL_SUFFIX);
        writeln("super();");
        
        for(Attribute attrib: nonDerivedAttribs) {
            MultiplicityType mult = attrib.getMultiplicity();
            int upper = mult.getUpper();
            if (upper == -1 || upper > 1) {
                // Multiple values -- initialize collection.
                String fieldName = nonDerivedAttribNames.get(attrib);

                if (nonDataTypeAttribs.contains(attrib)) {
                    // don't initialize, these are modeled as associations
                    continue;
                }
                
                String elemTypeName = CodeGenUtils.getTypeName(attrib.getType());
                
                String collTypeName;
                if (mult.isOrdered()) {
                    collTypeName = 
                        CodeGenUtils.getCollectionType(
                            ORDERED_COLLECTION_IMPL_CLASS, elemTypeName);
                } else {
                    collTypeName = 
                        CodeGenUtils.getCollectionType(
                            COLLECTION_IMPL_CLASS, elemTypeName);
                }
                
                writeln(
                    "this.",
                    fieldName,
                    " = new ",
                    collTypeName,
                    "();");
            }
        }
        endBlock();
        
        if (instanceAttributes.size() ==  0) {
            return;
        }

        // constructor
        newLine();
        ModelElement[] params = 
            nonDerivedAttribs.toArray(
                new ModelElement[nonDerivedAttribs.size()]);
        startConstructorBlock(cls, params, IMPL_SUFFIX);
        writeln("this();");
        newLine();
        writeln("// Make sure MOFID is assigned before any associations are");
        writeln("// initialized. (Hibernate does not call this constructor.)");
        writeln("save();");
        
        if (!nonDerivedAttribs.isEmpty()) {
            newLine();
        }
        for(Attribute attrib: nonDerivedAttribs) {
            String fieldName = nonDerivedAttribNames.get(attrib);
            String[] paramInfo = CodeGenUtils.getParam(attrib);
            if (nonDataTypeAttribs.contains(attrib)) {
                ComponentInfo componentInfo = componentInfoMap.get(attrib);
                    
                boolean isCollection = !componentInfo.isSingle();
                
                if (isCollection) {
                    startConditionalBlock(
                        CondType.IF, 
                        paramInfo[1], " != null && !", 
                        paramInfo[1], ".isEmpty()");
                } else {
                    startConditionalBlock(
                        CondType.IF, paramInfo[1], " != null");
                }
                writeln(
                    ASSOCIATION_INTERFACE,
                    " assoc = getOrCreateAssociation(", 
                    QUOTE, componentInfo.getBaseName(), QUOTE, ", ", 
                    componentInfo.isExposedEndFirst(), ");");
                if (isCollection) {
                    startBlock("for(Object o: ", paramInfo[1], ")");
                    writeln("assoc.add(this, (", ASSOCIABLE_INTERFACE, ")o);");
                    endBlock();
                } else {
                    writeln(
                        "assoc.add(this, (",
                        ASSOCIABLE_INTERFACE, ")", paramInfo[1], ");");
                }
                endBlock();
            } else {
                MultiplicityType mult = attrib.getMultiplicity();
                int upper = mult.getUpper();
                if (upper == -1 || upper > 1) {
                    // Copy the collection
                    writeln(
                        "if (",
                        paramInfo[1],
                        " != null) { ",
                        "this.",
                        fieldName,
                        ".addAll(",
                        paramInfo[1],
                        "); }");
                } else {
                    String valueExpr = paramInfo[1];
                    if (attrib.getType() instanceof EnumerationType) {
                        valueExpr = 
                            valueExpr 
                            + " != null ? " 
                            + valueExpr 
                            + ".toString() : null";                    }
                    
                    writeln("this.", fieldName, " = ", valueExpr, ";");
                }
            }       
        }
        endBlock();
    }

    /**
     * Generates public API accessors and mutators and internal Hiberate
     * accessors and mutators as necessary.
     * 
     * @param instanceAttributes collection of all instance attributes
     *                           (including those from super types)
     * @param nonDerivedAttribNames map of non-derived Attributes to their
     *                              field names
     * @param entityTypeAttribs set of component Attributes.
     */
    private void generateClassInstanceAttribMethods(
        Collection<Attribute> instanceAttributes,
        Map<Attribute, String> nonDerivedAttribNames,
        Set<Attribute> entityTypeAttribs)
    throws GenerationException
    {
        for(Attribute attrib: instanceAttributes) {
            if (entityTypeAttribs.contains(attrib)) {
                // Modeled as an association
                continue;
            }
            
            String fieldName = nonDerivedAttribNames.get(attrib);
            if (fieldName == null) {
                throw new UnsupportedOperationException(
                    "derived attributes not supported");
            }

            boolean primitiveConversionRequired = false;
            boolean enumerationConversionRequired = false;
            String internalTypeName;
            if (attrib.getType() instanceof EnumerationType) {
                internalTypeName = "String";
                enumerationConversionRequired = true;
            } else {
                internalTypeName = CodeGenUtils.getTypeName(attrib);
                if (Primitives.isPrimitiveType(internalTypeName)) {
                    internalTypeName = 
                        Primitives.convertPrimitiveToTypeName(
                            internalTypeName, true);
                    primitiveConversionRequired = true;
                }
            }
            
            // Hibernate accessor
            newLine();
            writeln("// Internal use only");
            startBlock(
                "public ",
                internalTypeName,
                " ",
                CodeGenUtils.getAccessorName(generator, attrib, false),
                IMPL_SUFFIX,
                "()");
            writeln("return ", fieldName, ";");
            endBlock();
            
            // Hibernate mutator. Some attributes are not 
            // changeable, but Hibernate will use this method to
            // set the value at load time.  This method isn't in the
            // class instance interface.
            newLine();
            writeln("// Internal use only");
            startBlock(
                "public void ",
                CodeGenUtils.getMutatorName(generator, attrib, false), IMPL_SUFFIX,
                "(", internalTypeName, " newValue)");
            writeln("this.", fieldName, " = newValue;");
            endBlock();
            
            int upper = attrib.getMultiplicity().getUpper();
            if (upper == 1) {
                // Public API accessor
                newLine();
                startAccessorBlock(attrib);

                writeln(
                    "logJmi(", 
                    QUOTE, CodeGenUtils.getAccessorName(generator, attrib), QUOTE, ");");
                
                if (primitiveConversionRequired) {
                    writeln(
                        internalTypeName, " value = ", 
                        CodeGenUtils.getAccessorName(generator, attrib, false), 
                        IMPL_SUFFIX, 
                        "();");
                    startConditionalBlock(CondType.IF, "value == null");
                    String primTypeName = 
                        Primitives.convertTypeNameToPrimitive(
                            internalTypeName);
                    writeln(
                        "return ", 
                        Primitives.getPrimitiveDefaultLiteral(primTypeName),
                        ";");
                    endBlock();
                    // let the JVM unbox it
                    writeln("return value;");
                } else if (enumerationConversionRequired) {
                    writeln(
                        internalTypeName, " value = ",
                        CodeGenUtils.getAccessorName(generator, attrib, false),
                        IMPL_SUFFIX,
                        "();");
                    startConditionalBlock(CondType.IF, "value == null");
                    writeln("return null;");
                    endBlock();
                    
                    // look up the literal's object
                    writeln(
                        "return ", 
                        CodeGenUtils.getTypeName(
                            attrib, EnumerationClassHandler.ENUM_CLASS_SUFFIX),
                        ".forName(value);");
                } else {
                    writeln(
                        "return ", 
                        CodeGenUtils.getAccessorName(generator, attrib, false), 
                        IMPL_SUFFIX,
                        "();");
                }
                endBlock();
                
                // Public API mutator (if any).
                if (attrib.isChangeable()) {
                    newLine();
                    startMutatorBlock(attrib);
                    
                    writeln(
                        "logJmi(", 
                        QUOTE, CodeGenUtils.getMutatorName(generator, attrib), QUOTE, ");");

                    // Fire event using the value from the API method so that
                    // primitive and enumeration conversions are done and we
                    // pass the converted value in the event.
                    writeln(
                        "super.fireAttributeSetEvent(",
                        QUOTE, attrib.getName(), QUOTE, ", ",
                        CodeGenUtils.getAccessorName(generator, attrib, true), 
                        "(), newValue);");
                    
                    String newValueExp = "newValue";
                    if (enumerationConversionRequired) {
                        newValueExp = 
                            "newValue != null ? newValue.toString() : null";
                    }
                    writeln(
                        CodeGenUtils.getMutatorName(generator, attrib, false), 
                        IMPL_SUFFIX,
                        "(", newValueExp, ");");
                    endBlock();
                }
            } else {
                if (upper == 0 || upper < -1) {
                    throw new GenerationException("bad upper value: " + upper);
                }

                // Public API accessor
                boolean isOrdered = attrib.getMultiplicity().isOrdered();
                newLine();
                startAccessorBlock(attrib);

                writeln(
                    "logJmi(", 
                    QUOTE, CodeGenUtils.getAccessorName(generator, attrib), QUOTE, ");");

                if (attrib.isChangeable()) {
                    if (isOrdered) {
                        writeln(
                            "return new ",
                            ATTRIB_LIST_WRAPPER_CLASS,
                            "<", CodeGenUtils.getTypeName(attrib.getType()), ">",
                            "(this, ", 
                            QUOTE, attrib.getName(), QUOTE, ", ",
                            CodeGenUtils.getAccessorName(generator, attrib, false), 
                            IMPL_SUFFIX, 
                            "());");
                    } else {
                        writeln(
                            "return new ",
                            ATTRIB_COLLECTION_WRAPPER_CLASS,
                            "<", CodeGenUtils.getTypeName(attrib.getType()), ">",
                            "(this, ", 
                            QUOTE, attrib.getName(), QUOTE, ", ",
                            CodeGenUtils.getAccessorName(generator, attrib, false), 
                            IMPL_SUFFIX, 
                            "());");
                    }
                } else {
                    if (isOrdered) {
                        writeln(
                            "return ", 
                            JAVA_UTIL_COLLECTIONS_CLASS, 
                            ".unmodifiableList(", 
                            CodeGenUtils.getAccessorName(generator, attrib, false),
                            IMPL_SUFFIX,
                            "());");
                    } else {
                        writeln(
                            "return ",
                            JAVA_UTIL_COLLECTIONS_CLASS, 
                            ".unmodifiableSet(",
                            CodeGenUtils.getAccessorName(generator, attrib, false),
                            IMPL_SUFFIX,
                            "());");                            
                    }
                }
                endBlock();
            }
        }
    }

    private void generateClassInstanceCheckConstraints(
        Collection<Attribute> attribs, 
        Collection<Reference> refs,
        Set<Attribute> componentAttribs)
    throws GenerationException
    {
        startBlock(
            "protected void checkConstraints(",
            JAVA_UTIL_LIST_CLASS, 
            "<", JavaHandlerBase.JMI_EXCEPTION_CLASS, "> errors, ",
            "boolean deepVerify)");
        
        // NOTE: These checks are equivalent to Netbeans implementation.
        // More could be tested.
        
        for(Attribute attrib: attribs) {
            int lower = attrib.getMultiplicity().getLower(); 
            int upper = attrib.getMultiplicity().getUpper();
            if (lower == 1 && upper == 1) {
                // Check component attributes via public API (let it handle the
                // magic of lookup), otherwise do it via the internal accessor.
                String suffix = "";
                if (!componentAttribs.contains(attrib)) {
                    suffix = IMPL_SUFFIX;
                }
                
                startConditionalBlock(
                    CondType.IF, 
                    CodeGenUtils.getAccessorName(generator, attrib, false), 
                    suffix, 
                    "() == null");
            } else if (upper != 1 && lower > 0) {
                // Check that lower-bounded multi-value attribute meets lower
                // bound
                startConditionalBlock(
                    CondType.IF, 
                    CodeGenUtils.getAccessorName(generator, attrib, false), "().size() < ",
                    lower);
            } else {
                continue;
            }
            
            // Find attribute.
            JavaClassReference ATTRIBUTE_CLASS = 
                new JavaClassReference(Attribute.class, false);
            writeln(
                ATTRIBUTE_CLASS, " attrib = findAttribute(",
                QUOTE, attrib.getName(), QUOTE, ");");
            writeln(
                "errors.add(new ", 
                JavaHandlerBase.WRONG_SIZE_EXCEPTION_CLASS,
                "(attrib));");
            endBlock();
        }
        
        for(Reference ref: refs) {
            int lower = ref.getMultiplicity().getLower(); 
            int upper = ref.getMultiplicity().getUpper();
            
            if (lower == 1 && upper == 1) {
                // Check that required single-value attribute has a value.
                startConditionalBlock(
                    CondType.IF, 
                    CodeGenUtils.getAccessorName(generator, ref), "() == null");
            } else if (upper != 1 && lower > 0) {
                // Check that lower-bounded multi-value attribute meets lower
                // bound
                startConditionalBlock(
                    CondType.IF, 
                    CodeGenUtils.getAccessorName(generator, ref), "().size() < ", lower);
            } else {
                continue;
            }

            AssociationEnd exposedEnd = ref.getExposedEnd();
            Association assoc = (Association)exposedEnd.getContainer();
            String exposedEndName = exposedEnd.getName();
            String referencedEndName = ref.getReferencedEnd().getName();
            JavaClassReference ASSOCIATION_END_CLASS = 
                new JavaClassReference(AssociationEnd.class, false);
            JavaClassReference REF_ASSOCIATION_BASE_CLASS = 
                new JavaClassReference(RefAssociationBase.class, false);
            writeln(
                ASSOCIATION_END_CLASS, " exposedEnd = findAssociationEnd(", 
                QUOTE, getAssociationIdentifier(assoc), QUOTE, ", ", 
                QUOTE, exposedEndName, QUOTE, ");");
            writeln(
                ASSOCIATION_END_CLASS, " referencedEnd = findAssociationEnd(", 
                QUOTE, getAssociationIdentifier(assoc), QUOTE, ", ", 
                QUOTE, referencedEndName, QUOTE, ");");
            writeln(
                "errors.add(", 
                REF_ASSOCIATION_BASE_CLASS,
                ".makeWrongSizeException(exposedEnd, referencedEnd, this));");
            endBlock();
        }
        
        endBlock();
    }

    public void generateClassProxy(MofClass cls)
        throws GenerationException
    {
        if (!isIncluded(cls)) {
            log.fine(
                "Skipping Excluded Class Proxy '" + cls.getName() + "'");
            return;
        }
        
        if (CodeGenUtils.isTransient(cls)) {
            if (getPassIndex() < numTransientPasses) {
                log.fine("Delegating Transient Class Proxy Implementation");
                transientHandler.generateClassProxy(cls);
            }
            return;
        }

        if (checkPassIndex(1)) {
            return;
        }
        
        String interfaceName = CodeGenUtils.getTypeName(cls, CLASS_PROXY_SUFFIX);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        String instanceInterfaceTypeName = CodeGenUtils.getTypeName(cls);
        String instanceImplTypeName = CodeGenUtils.getTypeName(cls, IMPL_SUFFIX);
        
        log.fine("Generating Class Proxy Implementation '" + typeName + "'");

        open(typeName);
        try {
            writeClassHeader(
                cls,
                typeName, 
                REF_CLASS_IMPL_CLASS.toString(),
                new String[] { interfaceName }, 
                JavaClassReference.computeImports(
                    METAMODEL_INITIALIZER_CLASS,
                    JAVA_UTIL_COLLECTIONS_CLASS,
                    JAVA_UTIL_ARRAYS_CLASS,
                    CREATE_INSTANCE_EVENT_CLASS),
                false,
                CLASS_PROXY_IMPL_COMMENT);
            
            String classIdentifier = getClassIdentifier(cls);
            writeConstant(
                "String", "_id", "\"" + classIdentifier + "\"", true);
            newLine();
            
            String queryCacheRegion = 
                HibernateMappingHandler.CACHE_REGION_SUFFIX + 
                HibernateMappingHandler.CACHE_REGION_QUERY_SUFFIX;
            String tableName =
                HibernateMappingHandler.computeBaseTableName(cls);
            if (tablePrefix != null) {
                queryCacheRegion = tablePrefix + queryCacheRegion;
                tableName = tablePrefix + tableName;
            }
            writeConstant(
                "String", "_queryCacheRegion", "\"" + queryCacheRegion + "\"",
                true);
            
            writeConstant(
                "String", "_table", "\"" + tableName + "\"", true);
            newLine();
            
            startConstructorBlock(
                cls,
                new String[] { REF_PACKAGE_CLASS.toString() },
                new String[] { "container" },
                true,
                CLASS_PROXY_SUFFIX + IMPL_SUFFIX);
            if (cls.isAbstract()) {
                writeln(
                    "super(container, null, ",
                    instanceInterfaceTypeName, ".class);");                
            } else {
                writeln(
                    "super(container, ",
                    instanceImplTypeName, ".class, ",
                    instanceInterfaceTypeName, ".class);");
            }
            
            newLine();
            writeln(
                METAMODEL_INITIALIZER_CLASS,
                ".getCurrentInitializer().setRefMetaObject(this, ", 
                QUOTE, cls.getName(), QUOTE, ");");
            
            endBlock();
            
            if (!cls.isAbstract()) {
                // No-arg factory method
                newLine();
                startCreatorBlock(cls, null, "");

                generateInstanceEventCall(null);
                
                String entityImplName = 
                    CodeGenUtils.getSimpleTypeName(cls, IMPL_SUFFIX);
                writeln(
                    entityImplName,
                    " obj = new ", instanceImplTypeName, "();");
                writeln("obj.save();");
                
                generateUpdateInstanceEventCall("obj");
                
                writeln("return obj;");
                endBlock();
                
                Collection<Attribute> allAttributes =
                    CodeGenUtils.contentsOfType(
                        cls, 
                        HierachySearchKindEnum.INCLUDE_SUPERTYPES, 
                        ScopeKindEnum.INSTANCE_LEVEL,
                        Attribute.class);
                for(Iterator<Attribute> i = allAttributes.iterator(); 
                    i.hasNext(); ) 
                {
                    Attribute attrib = i.next();
                    
                    if (attrib.isDerived()) {
                        i.remove();
                    }
                }
                
                // factory method                
                if (allAttributes.size() > 0) {
                    newLine();
                    
                    ModelElement[] params = 
                        allAttributes.toArray(
                            new ModelElement[allAttributes.size()]);
                    startCreatorBlock(cls, params, "");  

                    ArrayList<String> paramNames = new ArrayList<String>();
                    for(Attribute attrib: allAttributes) {
                        String[] paramInfo = CodeGenUtils.getParam(attrib);
                        paramNames.add(paramInfo[1]);
                    }

                    generateInstanceEventCall(paramNames);

                    writeln(
                        entityImplName,
                        " obj = new ",
                        instanceImplTypeName,
                        "(");
                    increaseIndent();

                    for(Iterator<String> i = paramNames.iterator(); 
                        i.hasNext(); )
                    {    
                        writeln(i.next(), i.hasNext() ? "," : ");");
                    }
                    decreaseIndent();

                    generateUpdateInstanceEventCall("obj");
                    
                    // NOTE: save is called in the constructor
                    writeln("return obj;");
                    endBlock();
                }
            }

            newLine();
            writeCheckConstraints();
            
            newLine();
            startBlock("public String getClassIdentifier()");
            writeln("return _id;");
            endBlock();
            
            newLine();
            startBlock("public String getTable()");
            writeln("return _table;");
            endBlock();
            
            newLine();
            startBlock("public String getQueryCacheRegion()");
            writeln("return _queryCacheRegion;");
            endBlock();
            
            newLine();
            
            // TODO: collect this information once (rather than recomputing
            // for each class in instance and proxy generation)
            Collection<Reference> instanceReferences =
                CodeGenUtils.contentsOfType(
                    cls,
                    HierachySearchKindEnum.INCLUDE_SUPERTYPES, 
                    VisibilityKindEnum.PUBLIC_VIS,
                    Reference.class);

            Map<Reference, ReferenceInfo> refInfoMap = 
                buildRefInfoMap(instanceReferences);
            
            Map<Association, ReferenceInfo> unrefAssocRefInfoMap =
                new HashMap<Association, ReferenceInfo>();

            Collection<Association> unreferencedAssociations = 
                CodeGenUtils.findUnreferencedAssociations(
                    assocInfoMap,
                    cls,
                    instanceReferences, 
                    unrefAssocRefInfoMap);
            
            Collection<Attribute> instanceAttributes =
                CodeGenUtils.contentsOfType(
                    cls,
                    HierachySearchKindEnum.INCLUDE_SUPERTYPES, 
                    VisibilityKindEnum.PUBLIC_VIS,
                    ScopeKindEnum.INSTANCE_LEVEL,
                    Attribute.class);
            Set<Attribute> nonDataTypeAttribs = new HashSet<Attribute>();
            for(Attribute attrib: instanceAttributes) {
                if (attrib.isDerived()) {
                    continue;
                }
                
                boolean isDataType = attrib.getType() instanceof DataType;
                
                if (!isDataType) {
                    nonDataTypeAttribs.add(attrib);
                }
            }

            Map<Attribute, ComponentInfo> componentInfoMap = 
                buildComponentInfoMap(
                    cls,
                    nonDataTypeAttribs);

            List<ReferenceInfo> refInfos = 
                gatherRefInfos(
                    instanceReferences, refInfoMap, 
                    unreferencedAssociations, unrefAssocRefInfoMap,
                    componentInfoMap);

            if (cls.isAbstract() || refInfos.isEmpty()) {
                startBlock(
                    "public String getAssociationColumnName(String assocType, boolean firstEnd)");
                writeln("throw new UnsupportedOperationException();");
                endBlock();
            } else {
                generateGetAssociationColumnNameMethod(refInfos);
            }
            
            writeEntityFooter();
        }
        finally {
            close();
        }
    }
    
    /**
     * Generates code to fire an {@link CreateInstanceEvent} when a class 
     * instance implementation is instantiated.
     * 
     * @param paramNames method parameter names containing the arguments used
     *                   to construct the object, or null
     */
    private void generateInstanceEventCall(List<String> paramNames)
    {
        writeln(
            CREATE_INSTANCE_EVENT_CLASS, " event = new ", CREATE_INSTANCE_EVENT_CLASS, "(");
        increaseIndent();
        writeln("this,");
        if (paramNames == null || paramNames.isEmpty()) {
            writeln("null);");
        } else {
            writeln(JAVA_UTIL_COLLECTIONS_CLASS, ".unmodifiableList(");
            increaseIndent();
            // NOTE jvs 30-Jun-2008:  we have to qualify java.lang.Object
            // here because the metamodel (e.g. UML) may use
            // "Object" as a classname.
            writeln(JAVA_UTIL_ARRAYS_CLASS, ".asList(new java.lang.Object[] {");
            increaseIndent();
            Iterator<String> paramIter = paramNames.iterator();
            while(paramIter.hasNext()) {
                String paramName = paramIter.next();
                
                writeln(paramName, paramIter.hasNext() ? "," : " })));");
            }
            decreaseIndent();
            decreaseIndent();
        }
        decreaseIndent();

        writeln("getHibernateRepository().enqueueEvent(event);");
    }
    
    /**
     * Generates code to update an existing {@link CreateInstanceEvent} with
     * the created instance.
     * 
     * @param instanceName variable name pointing to the newly constructed
     *                     instance
     */
    private void generateUpdateInstanceEventCall(String instanceName)
    {
        writeln("event.setInstance(", instanceName, ");");
    }
    
    public void generatePackage(MofPackage pkg)
        throws GenerationException
    {
        if (!isIncluded(pkg)) {
            log.fine(
                "Skipping Excluded Package '" + pkg.getName() + "'");
            return;
        }

        if (CodeGenUtils.isTransient(pkg)) {
            if (getPassIndex() < numTransientPasses) {
                log.fine("Delegating Transient Package Implementation");
                transientHandler.generatePackage(pkg);
            }
            return;
        }

        if (checkPassIndex(1)) {
            return;
        }
        
        String interfaceName = 
            CodeGenUtils.getTypeName(pkg, PACKAGE_SUFFIX);
        
        String typeName = interfaceName + IMPL_SUFFIX;

        log.fine("Generating Package Implementation '" + typeName + "'");

        open(typeName);
        try {
            writeClassHeader(
                pkg,
                typeName, 
                REF_PACKAGE_IMPL_CLASS.toString(),
                new String[] { interfaceName }, 
                JavaClassReference.computeImports(METAMODEL_INITIALIZER_CLASS),
                false,
                PACKAGE_IMPL_COMMENT);
            
            // Generate fields for all nested packages, class proxies and
            // associations.
            
            ArrayList<String> packageFieldNames = new ArrayList<String>();
            Collection<MofPackage> packages =
                CodeGenUtils.contentsOfType(pkg, MofPackage.class);
            
            Collection<MofPackage>
                aliasedPackages = new ArrayList<MofPackage>();

            Collection<Import> imports = 
                CodeGenUtils.contentsOfType(pkg, Import.class);
            for(Import imp: imports) {
                // Import is not a Feature, so contentsOfType throws if we
                // try to get it to filter on visibility.
                if (imp.isClustered() && 
                    VisibilityKindEnum.PUBLIC_VIS.equals(imp.getVisibility()))
                {
                    Namespace ns = imp.getImportedNamespace();
                    if (ns instanceof MofPackage &&
                        VisibilityKindEnum.PUBLIC_VIS.equals(
                            ((MofPackage) ns).getVisibility()))
                    {
                        MofPackage importedPkg = (MofPackage) ns;
                        if (!clusteringMap.containsKey(importedPkg)) {
                            // This is the first time we've seen a clustering
                            // reference to importedPkg.  Arbitrarily designate
                            // this as the "primary" instance, and treat it
                            // just like a true composite package.  Remember
                            // its parent path as a spanning tree edge so that
                            // we can generate aliased references to it.
                            clusteringMap.put(importedPkg, pkg);
                            packages.add(importedPkg);
                        } else {
                            // We've seen a clustering for importedPkg before,
                            // so treat this reference as an alias to
                            // the primary.
                            aliasedPackages.add(importedPkg);
                        }
                    }
                }
            }

            boolean hasPackages = !packages.isEmpty();
            boolean hasAliasedPackages = !aliasedPackages.isEmpty();
            if (hasPackages) {
                writeln("// Packages");
            }
            for(MofPackage nestedPkg: packages) {
                String fieldName = 
                    writeField(
                        nestedPkg, PRIVATE_SCOPE, true, false, PACKAGE_SUFFIX);
                packageFieldNames.add(fieldName);
            }
            
            ArrayList<String> classFieldNames = new ArrayList<String>();
            Collection<MofClass> classes = 
                CodeGenUtils.contentsOfType(pkg, MofClass.class);
            boolean hasClasses = !classes.isEmpty();
            if (hasClasses) {
                if (hasPackages) {
                    newLine();
                }
                writeln("// Class Proxies");
            }
            for(MofClass cls: classes) {
                String fieldName =
                    writeField(
                        cls, PRIVATE_SCOPE, true, false, CLASS_PROXY_SUFFIX);
                classFieldNames.add(fieldName);
            }
            
            ArrayList<String> assocFieldNames = new ArrayList<String>();
            Collection<Association> assocs = 
                CodeGenUtils.contentsOfType(pkg, Association.class);
            boolean hasAssocs = !assocs.isEmpty();
            if (hasAssocs) {
                if (hasPackages || hasClasses) {
                    newLine();
                }
                writeln("// Associations");
            }
            for(Association assoc: assocs) {
                String fieldName =
                    writeField(assoc, PRIVATE_SCOPE, true, false, "");
                assocFieldNames.add(fieldName);
            }
            newLine();
            
            // constructor (initializes fields)       
            startBlock(
                "public ",
                CodeGenUtils.getSimpleTypeName(pkg, PACKAGE_SUFFIX + IMPL_SUFFIX),
                "(",
                REF_PACKAGE_CLASS.toString(), " container)");
            writeln("super(container);");

            newLine();
            writeln(
                METAMODEL_INITIALIZER_CLASS,
                ".getCurrentInitializer().setRefMetaObject(this, ", 
                QUOTE, pkg.getName(), QUOTE, ");");
            newLine();

            // initialize nested package fields
            Iterator<String> nameIter;
            Iterator<MofPackage> pkgIter;
            for(
                nameIter = packageFieldNames.iterator(),
                    pkgIter = packages.iterator();
                nameIter.hasNext() && pkgIter.hasNext(); )
            {
                String fieldName = nameIter.next();
                MofPackage nestedPkg = pkgIter.next();
                writeln(
                    "this.",
                    fieldName,
                    " = new ",
                    CodeGenUtils.getTypeName(
                        nestedPkg, PACKAGE_SUFFIX + IMPL_SUFFIX),
                    "(this);");
                writeln(
                    "super.addPackage(", 
                    QUOTE, nestedPkg.getName(), QUOTE, 
                    ", this.", fieldName, ");");
            }

            // Once the import spanning tree is complete, it
            // is safe to add all of the aliases (the addAliasPackages
            // operation requires refPackage invocations along
            // the edges of the spanning tree).  So we do that as
            // a final pass from the root down (non-root packages
            // will be called by the generated implementations of
            // addAliasPackages in their parents).
            if ((pkg.getContainer() == null)
                && !clusteringMap.containsKey(pkg))
            {
                writeln("addAliasPackages();");
            }
            
            if (hasPackages) {
                newLine();
            }
            
            // initialize class proxy fields 
            Iterator<MofClass> clsIter;
            for(
                nameIter = classFieldNames.iterator(),
                    clsIter = classes.iterator();
                nameIter.hasNext() && clsIter.hasNext(); )
            {
                String fieldName = nameIter.next();
                MofClass nestedCls = clsIter.next();
                writeln(
                    "this.",
                    fieldName,
                    " = new ",
                    CodeGenUtils.getTypeName(
                        nestedCls, CLASS_PROXY_SUFFIX + IMPL_SUFFIX),
                    "(this);");
                writeln(
                    "super.addClass(", 
                    QUOTE, nestedCls.getName(), QUOTE, 
                    ", this.", fieldName, ");");
            }

            if (hasClasses) {
                newLine();
            }
            
            // initialize association fields
            Iterator<Association> assocIter;
            for(
                nameIter = assocFieldNames.iterator(),
                    assocIter = assocs.iterator();
                nameIter.hasNext() && assocIter.hasNext(); )
            {
                String fieldName = nameIter.next();
                Association assoc = assocIter.next();
                writeln(
                    "this.",
                    fieldName,
                    " = new ",
                    CodeGenUtils.getTypeName(assoc, IMPL_SUFFIX),
                    "(this);");
                writeln(
                    "super.addAssociation(", 
                    QUOTE, assoc.getName(), QUOTE, 
                    ", this.", fieldName, ");");
            }
            
            endBlock();
            newLine();
            
            // generate accessor methods

            if (hasPackages || hasAliasedPackages) {
                writeln("// Package Accessors");
                newLine();
            }

            // package accessors
            for(
                nameIter = packageFieldNames.iterator(),
                    pkgIter = packages.iterator();
                nameIter.hasNext() && pkgIter.hasNext(); )
            {
                MofPackage nestedPkg = pkgIter.next();
                startPackageAccessorBlock(nestedPkg, PACKAGE_SUFFIX);
                
                writeln("return ", nameIter.next(), ";");                

                endBlock();
                newLine();
            }

            // aliased package accessors
            for(
                pkgIter = aliasedPackages.iterator();
                pkgIter.hasNext(); )
            {
                MofPackage nestedPkg = pkgIter.next();
                startPackageAccessorBlock(nestedPkg, PACKAGE_SUFFIX);

                // Generate a series of refPackage calls from the root
                // down to this package.  The first part of the path
                // will be via containment edges, and the second part
                // will be along import spanning tree edges.  Based
                // on the information we have available, it's necessary
                // to build this up in reverse order.

                MofPackage parentPkg = clusteringMap.get(nestedPkg);
                assert(parentPkg != null);

                List<String> pkgPath = new ArrayList<String>();

                for (;;) {
                    pkgPath.add(0, parentPkg.getName());
                    MofPackage grandParentPkg = clusteringMap.get(parentPkg);
                    if (grandParentPkg == null) {
                        // we've found the trunk of the import spanning
                        // tree; from here on up, we'll go by containment
                        // edges instead
                        break;
                    }
                    parentPkg = grandParentPkg;
                }

                // prepend the containing packages; skip the last one,
                // since it's accounted for as the last parentPkg above
                List<?> nonClusteredPath = parentPkg.getQualifiedName();
                for (int i = nonClusteredPath.size() - 2; i >= 0; --i) {
                    pkgPath.add(0, nonClusteredPath.get(i).toString());
                }

                // refOutermostPackage will give us the root
                write(
                    "return (",
                    CodeGenUtils.getTypeName(nestedPkg, PACKAGE_SUFFIX),
                    ") refOutermostPackage().");

                // now walk down from the root along the path
                // we built up; skip the root itself (i=0) since
                // that's already accounted for
                for (int i = 1; i < pkgPath.size(); ++i) {
                    String pkgName = pkgPath.get(i).toString();
                    write(
                        "refPackage(",
                        QUOTE,
                        pkgName,
                        QUOTE,
                        ").");
                }

                // finally, access the original package we were looking for
                // (the path above does not include it)
                writeln(
                    "refPackage(",
                    QUOTE,
                    nestedPkg.getName(),
                    QUOTE,
                    ");");

                endBlock();
                newLine();
            }

            // Fill in addAliasPackages method implementations.  This
            // has two steps:  (1) recursively call it for any child
            // packages (whether by containment or spanning tree edge),
            // and (2) for this package, call the addPackage registration
            // method for all aliased imports.
            startBlock("public void addAliasPackages()");
            for(String packageFieldName : packageFieldNames) {
                writeln(
                    "((" , REF_PACKAGE_BASE_CLASS, ") ",
                    packageFieldName,
                    ").addAliasPackages();");
            }
            
            for(
                pkgIter = aliasedPackages.iterator();
                pkgIter.hasNext(); )
            {
                MofPackage nestedPkg = pkgIter.next();

                writeln(
                    "super.addPackage(", 
                    QUOTE, nestedPkg.getName(), QUOTE, 
                    ", this.get", CodeGenUtils.getSimpleTypeName(nestedPkg),
                    "());");
            }
            endBlock();
            
            // class proxy accessors
            if (hasClasses) {
                if (hasPackages || hasAliasedPackages) {
                    newLine();
                }
                writeln("// Class Proxy Accessors");
                newLine();
            }
            
            for(
                nameIter = classFieldNames.iterator(),
                    clsIter = classes.iterator();
                nameIter.hasNext() && clsIter.hasNext(); )
            {
                MofClass cls = clsIter.next();
                startPackageAccessorBlock(cls, CLASS_PROXY_SUFFIX);
                
                writeln("return ", nameIter.next(), ";");
                
                endBlock();
                newLine();
            }

            // association accessors
            if (hasAssocs) {
                if (hasPackages || hasAliasedPackages || hasClasses) {
                    newLine();
                }
                writeln("// Association Accessors");
                newLine();
            }
            for(
                nameIter = assocFieldNames.iterator(),
                    assocIter = assocs.iterator();
                nameIter.hasNext() && assocIter.hasNext(); )
            {
                Association assoc = assocIter.next();
                startPackageAccessorBlock(assoc, "");
                
                writeln("return ", nameIter.next(), ";");
                
                endBlock();
                newLine();
            }
            
            newLine();
            startCheckConstraints();
            writeln(
                CONSTRAINT_CHECKER_CLASS, 
                " cc = new ", 
                CONSTRAINT_CHECKER_CLASS, 
                "(getHibernateRepository());");
            writeln("cc.verifyConstraints(this, errors, deepVerify);");
            endBlock();
            
            writeEntityFooter();
        }
        finally {
            close();
        }
    }
    
    private boolean checkPassIndex(int min) throws GenerationException
    {
        int passIndex = getPassIndex();
        if (passIndex < min || passIndex >= numPasses) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Retrieves the unique identifier for the given {@link MofClass}.  Checks
     * the cache (in {@link #classIdentifierMap}) first, and if not found,
     * generates a value based on the class name.
     *
     * @param cls {@link MofClass} to get an identifier for
     * @return the class's unique identifier
     * @throws GenerationException if there's an error computing the identifier
     */
    private String getClassIdentifier(MofClass cls) throws GenerationException
    {
        if (classIdentifierMap.containsKey(cls)) {
            return classIdentifierMap.get(cls);
        }

        // Build a string based on the class's name, with packages appended
        // in reverse order.  E.g., "Driver.sample.eem".  Previously we
        // generated a hash over the class, its supertypes and their 
        // attributes.  This makes upgrades cumbersome since adding an 
        // attribute invalidates all existing associations.
        
        StringBuilder idBuilder = new StringBuilder(cls.getName());
        
        Namespace container = cls;
        while((container = container.getContainer()) != null) {
            idBuilder.append('.').append(container.getName());
        }
        
        String id = idBuilder.toString();
        
        if (classIdentifierMap.values().contains(id)) {
            throw new GenerationException("duplicate identifier error: " + id);
        }
        
        classIdentifierMap.put(cls, id);
        
        return id;
    }
    
    /**
     * Retrieves the unique identifier for the given {@link Association}.  
     * Checks the cache (in {@link #assocIdentifierMap}) first, and if not 
     * found, generates a value based on the association name, 
     * association end names, association end types, and multiplicity.
     *
     * @param assoc {@link Association} to get an identifier for
     * @return the association's unique identifier
     * @throws GenerationException if there's an error computing the identifier
     */
    private String getAssociationIdentifier(Association assoc)
        throws GenerationException
    {
        if (assocIdentifierMap.containsKey(assoc)) {
            return assocIdentifierMap.get(assoc);
        }

        try {
            MessageDigest sha1md = MessageDigest.getInstance("SHA-1");
            
            List<?> qualifiedName = assoc.getQualifiedName();
            for(Object o: qualifiedName) {
                sha1md.update(o.toString().getBytes());
                sha1md.update((byte)'_');
            }

            for(Object o: assoc.getContents()) {
                if (o instanceof AssociationEnd) {
                    AssociationEnd end = (AssociationEnd)o;
                    
                    sha1md.update(end.getName().getBytes());
                    
                    for(Object o2: end.getType().getQualifiedName()) {
                        sha1md.update(o2.toString().getBytes());
                        sha1md.update((byte)'_');
                    }
                    
                    MultiplicityType mult = end.getMultiplicity();
                    sha1md.update((byte)(mult.isOrdered() ? 1 : 0));
                    sha1md.update((byte)(mult.isUnique() ? 1 : 0));
                    int lower = mult.getLower();
                    sha1md.update((byte)(lower >>> 24));
                    sha1md.update((byte)(lower >>> 16));
                    sha1md.update((byte)(lower >>> 8));
                    sha1md.update((byte)lower);
                    int upper = mult.getUpper();
                    sha1md.update((byte)(upper >>> 24));
                    sha1md.update((byte)(upper >>> 16));
                    sha1md.update((byte)(upper >>> 8));
                    sha1md.update((byte)upper);
                }
            }
            
            String digestStr = computeDigestString(sha1md);
            
            assocIdentifierMap.put(assoc, digestStr);
            return digestStr;
        } catch (NoSuchAlgorithmException e) {
            throw new GenerationException(e);
        }
    }

    /**
     * Converts a {@link MessageDigest} into a hexadecimal string.
     * 
     * @param md MessageDigest
     * @return hex string
     */
    private String computeDigestString(MessageDigest md)
    {
        byte[] digest = md.digest();
        
        StringBuffer digestStrBuf = new StringBuffer();
        for(int i = 0; i < digest.length; i++) {
            String digestByteStr = 
                Integer.toHexString((int)digest[i] & 0xFF);
            if (digestByteStr.length() < 2) {
                digestStrBuf.append('0');
            }
            digestStrBuf.append(digestByteStr);
        }
        
        String digestStr = digestStrBuf.toString();
        return digestStr;
    }

    /**
     * Convert an {@link AssociationKindEnum} to name of one of the 
     * model-specific {@link HibernateAssociation} subclasses generated 
     * in {@link #generateAssociationStorageSubclass(JavaClassReference, JavaClassReference, AssociationKindEnum, String, String)}
     * 
     * @param refInfo description of the reference
     * @return full name of the implementation class
     */
    private String makeType(ReferenceInfo refInfo)
        throws GenerationException
    {
        AssociationKindEnum kind = refInfo.getKind();
        
        boolean isOrdered = refInfo.isOrdered();
        boolean isEitherOrdered = 
            isOrdered || refInfo.isOrdered(refInfo.getExposedEndIndex());
        
        switch(kind)
        {
        case ONE_TO_ONE:
            return assocOneToOneLazyClass.toString();
            
        case ONE_TO_MANY:
            if (isEitherOrdered) {
                return assocOneToManyLazyOrderedClass.toString();
            } else if (isHighCardinalityAssociation(refInfo)) {
                return assocOneToManyLazyHighCardinalityClass.toString();
            } else {
                return assocOneToManyLazyClass.toString();
            }

        case MANY_TO_MANY:
            if (isOrdered) {
                return assocManyToManyLazyOrderedClass.toString();
            } else {
                return assocManyToManyLazyClass.toString();
            }
        }
        
        throw new IllegalArgumentException(
            "Unknown AssociationKindEnum: " + kind);
    }
    
    /**
     * Determines the base name of the accessor or mutator on the correct
     * type of {@link HibernateAssociation} subclass for the given end of 
     * the described {@link Reference}.
     * 
     * @param refInfo description of the Reference
     * @param isRefEnd if the referenced (vs. exposed) end is requested
     * @return accessor/mutator base name
     */
    private String getReferenceEndName(
        ReferenceInfo refInfo, boolean isRefEnd)
    {
        int index = 
            isRefEnd
                ? refInfo.getReferencedEndIndex()
                : refInfo.getExposedEndIndex();
        assert(index >= 0 && index <= 1);

        switch(refInfo.getKind()) {
        case ONE_TO_ONE:
            return index == 0 ? "Parent" : "Child";
            
        case ONE_TO_MANY:
            if (refInfo.isSingle(index)) {
                return "Parent";
            } else {
                return "Children";
            }
            
        case MANY_TO_MANY:
            return "Target";
        }

        throw new IllegalArgumentException(
            "Unknown AssociationKindEnum: " + refInfo.getKind());
    }
    
    /**
     * Retrieves the name of the class instance inteface that represents the
     * given end of the described {@link Reference}.
     * 
     * @param refInfo description of the Reference
     * @param isRefEnd if the referenced (vs. exposed) end is requested
     * @return class instance interface name
     */
    private String getReferenceEndType(
        ReferenceInfo refInfo, boolean isRefEnd)
    {
        int index = 
            isRefEnd
                ? refInfo.getReferencedEndIndex()
                : refInfo.getExposedEndIndex();
        assert(index >= 0 && index <= 1);

        return refInfo.getEndType(index);
    }
    
    private String getReferenceAccessorName(ReferenceInfo refInfo)
    {
        return 
            "get" + 
            generator.transformIdentifier(refInfo.getReferencedEndBaseName()) +
            IMPL_SUFFIX;
    }

    private String getReferenceMutatorName(ReferenceInfo refInfo)
    {
        return 
            "set" + 
            generator.transformIdentifier(refInfo.getReferencedEndBaseName()) +
            IMPL_SUFFIX;
    }
    
    /**
     * Returns the name of the generic {@link RefAssociation} subclass that 
     * handles the described {@link Association}.
     * 
     * @param assocInfo description of the Association
     * @return name of the type that handles it
     */
    private String makeRefType(AssociationInfo assocInfo)
    {
        StringBuffer type = new StringBuffer();
        switch(assocInfo.getKind()) {
        case ONE_TO_ONE:
            type.append(REF_ASSOCIATION_ONE_TO_ONE_IMPL_CLASS);
            break;
            
        case ONE_TO_MANY:
            type.append(REF_ASSOCIATION_ONE_TO_MANY_IMPL_CLASS);
            break;
            
        case MANY_TO_MANY:
            type.append(REF_ASSOCIATION_MANY_TO_MANY_IMPL_CLASS);
            break;

        default:
            throw new IllegalArgumentException(
                "Unknown AssociationKindEnum: " + assocInfo.getKind());
        }

        type
            .append("<")
            .append(assocInfo.getEndType(0))
            .append(", ")
            .append(assocInfo.getEndType(1))
            .append(">");

        return type.toString();
    }
    
    private Collection<Classifier> collectSupertypes(Classifier cls)
    {
        Set<Classifier> result = new LinkedHashSet<Classifier>();
        
        collectSupertypes(cls, result);
        
        return result;
    }
    
    private void collectSupertypes(Classifier cls, Set<Classifier> result)
    {
        for(Classifier supertype: 
                GenericCollections.asTypedList(
                    cls.getSupertypes(), Classifier.class))
        {
            if (!result.contains(supertype)) {
                collectSupertypes(supertype, result);
            }
        }
        
        result.add(cls);
    }
    
    public static boolean isHighCardinalityAssociation(
        AssociationInfo assocInfo)
    {
        if (assocInfo.getKind() != AssociationKindEnum.ONE_TO_MANY) {
            return false;
        }
        
        if (assocInfo instanceof ComponentInfo) {
            // Tag, if any, is on Attribute instance
            return CodeGenUtils.isHighCardinalityAssociation(
                ((ComponentInfo)assocInfo).getOwnerAttribute());
        } else {
            return CodeGenUtils.isHighCardinalityAssociation(
                assocInfo.getAssoc());
        }
    }

    /**
     * AssocMethodGenerator generates code for association methods within
     * a class instance implementation.
     */
    private static interface AssocMethodGenerator
    {
        /**
         * Generate code for the described {@link ReferenceInfo reference}.
         */
        public void generate(ReferenceInfo refInfo) throws GenerationException;
    }
    
    /**
     * AssociationRemoveOrderComparator sorts {@link ReferenceInfo} objects
     * into the appropriate removal order. 
     */
    private static class AssociationRemoveOrderComparator
        implements Comparator<ReferenceInfo>
    {
        private final Map<Classifier, Integer> typeOrderMap;
        private final Map<AssociationEnd, Integer> assocEndOrderMap;
        
        public AssociationRemoveOrderComparator(
            Map<Classifier, Integer> typeOrderMap,
            Map<AssociationEnd, Integer> assocEndOrderMap)
        {
            this.typeOrderMap = typeOrderMap;
            this.assocEndOrderMap = assocEndOrderMap;
        }
        
        public int compare(ReferenceInfo refInfo1, ReferenceInfo refInfo2)
        {
            AssociationEnd exposedEnd1 = 
                refInfo1.getEnd(refInfo1.getExposedEndIndex());
            AssociationEnd exposedEnd2 = 
                refInfo2.getEnd(refInfo2.getExposedEndIndex());
            
            Classifier exposedEndCls1 = exposedEnd1.getType();
            if (exposedEnd1 instanceof AliasType) {
                exposedEndCls1 = ((AliasType)exposedEndCls1).getType();
            }
            Classifier exposedEndCls2 = exposedEnd2.getType();
            if (exposedEnd2 instanceof AliasType) {
                exposedEndCls2 = ((AliasType)exposedEndCls2).getType();
            }
            
            int o1 = typeOrderMap.get(exposedEndCls1);
            int o2 = typeOrderMap.get(exposedEndCls2);
            assert(o1 != 0);
            assert(o2 != 0);
            
            int c = o1 - o2;
            if (c != 0) {
                return c;
            }
            
            o1 = assocEndOrderMap.get(exposedEnd1);
            o2 = assocEndOrderMap.get(exposedEnd2);
            assert(o1 != 0);
            assert(o2 != 0);
            
            return o1 - o2;
        }        
    }
}
